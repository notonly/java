BattleShip (the classic naval combat game) <-- by MB (Milton Bradley ..

1.4 using CLASSPATH  effectively


java -classpath ~/example1/ex1.jar Example1

1) java interpreter looks dirs defined in CLASSPATH;

2) os tracing tool (trace, strace, truss, ktrace),  can see Java opens (or, stat, or access) the class file.

3) jdk class files,  in system props  (sun.boot.class.path)

4) jar file, unlike the single class file (using directory in classpath);  JAR file, needs to be in CLASSPATH defn

5) Web applications may NOT use bootpath or CLASSPATH;  those web apps having own ClassLoader, and set web app classpath to include WEB-INF/classes  (and the JAR files in WEB-INF/lib)

6) Create class files into CLASSPATH directories

   javac -d $HOME/classes Example1.java
	 java  -cp $HOME/classes/ pkg.Example1   (note, this command can be run from anywhere)


7) managing CLASSPATH in own env,

   set a base/main directory in $CLASSPATH
	 then make OPT_JARS including other JAR files or class-dirs;  and then adding them to $CLASSPATH


8)


1.5 Code Examples

   GitHub (https://github.com/IanDarwin/javasrcee)  

	 https://github.com/notonly/javasrc

	    javasrc
			darwinsys-api  (



1.9 Dealing with Deprecation Warnings

   javac -deprecation Example1.java

	 1) @Deprecated on method or class
	 2) @deprecated on javadoc

	 *) Rule of thumb:  if method/class is deprecated; NEW CODE should avoid using it.


1.10  check if we us  "System.properties"  for Runtime Debug (most likely NOT,  because, turn it on for RunTime requires rebooting the JVM.   We have re-load;  also some JMX stuff ... for updating the Log4J log level etc) ...

    if (System.getProperty("debug.fetch") != null) {
		    System.err.println("runtime debugging turned on");
		}

  java Example1   // will not see the debug

	java -Ddebug.fetch Example1   // will see the debugging, because the Runtime System.properties turned on, and code/class got the value


1.11  Correctness with Assertions


... Fast Forwarding ...

Chapter 9: Functional Programming

1) pure function, no side-effects, results depend only on their inputs and not on mutable state elsewhere in program
2) first-class function
3) Immutable data
4) extensive use of recusion and Lazy Evaluation


9.1 Using lambdas/closures in place of inner classes


My own notes:  how does Java implement (Java Compiler) handle closure -->  in the hood, still make closure to inner-class, and then some dynamic link (for groovy) type logic (vaguely remembered the Brian Goetz's presention ...


9.2 Using Predefined Interfaces, instead of own 

1) java.util.function package


interface Predicate<T> {
    boolean test(T t);
}


public List<Clazz> search(Predicate p);



9.3 simplifying processing with streams


1) production methods

2) passing methods (intermediate)  -- distinct, filter, limit, map, peek, sorted, unsorted

3) terminating methods -- count, findFirst, max, min, reduce, sum, collect ...



9.4 improving throughput with parallel streams and collections

<== no example from the book, just four bulletin-points


9.5 creating own functional interfaces

1) make sure just 1 non-default (or non-optional) method in that Interface; or

2) use @FunctionalInterface annotation 

   a.  define own functional interface

	      public interface MyFuncIntfc {
				    int computer(int x);
				}


				OR

				@FunctionalInterface
				public interface MyFuncIntfc {
				    int computer(int x);
				}

	 b.  apply it

	      public class ProcessInts {
				    static int[] ins = {0, 1, 2, 3};
						
						// THIS IS REALLY WHAT I NEED MORE USAGE ON THESE PATTERNS; (I more familiar with small closure usage) ...
						// Passing in the functions ... ;  and inside apply it
						static int doMath(int n, Function<Integer, Integer> func) {
						    return func.apply(n);
						}

			      public void static main(String[] args) {
							...
						}
				}




9.6 Using Existing Code as Functional with Method References   (Functional METHODS)  -->  MyClass::myFunc  ...

   If already have existing code matching a functional interface, and want to use it without renaming methods to match the interface name.


   Arrays.sort(names, String::compareToIgnoreCase);  // names array of {"a", "b", "d", "c"};

   Arrays.sort(names, String.CASE_INSENSITVIE_ORDER);  // the existing comparator


9.7 Java Mixins: Mixing in Methods 

1) what is mixin ? 

2) using "static import" feature to implement mixin 

     (cons:  static method, not instance method) 


3) pull method from Multiple Interfaces ....

   interface Bar {
	    default String filter(String s) {
				return "Filtered " + s;
	  }

		interface Foo {
			  default String convolve(String s) {
				  return "Convolved " + s;
		}



   public class MixinsDemo implements Foo, Bar {
	   ...

		 private String process(String s) {
		 	 return filter(convolve(s));  // methods mixed in
		 }
	 }




Alas,  this book finished Functional Programming in such a short chapter ....



Chapter 19 Processing JSON Data

19.1 creating JSON string, using StringBuilder


19.2 Parsing and Writing JSON with Jackson

  ObjectMapper 

	  mapper.writeValue(System.out, new Person("name", 33));


	  mapper.readValue(jsonInputStream,  Person.class);


19.3 Parsing and Writing JSON with org.json

  ? mid-size, widely used JSON API   -- This is also used in Android app


	// READ 

   JSONObject obj = new JSONObject(new JSONTokener(jsonInputStream));  // InputStream can come from file

	 System.out.println("name : " + obj.getString("name"));


	// WRITE
	JSONObject obj = new JSONObject();
	obj.put("name", "Ray");
	   .put("age", 33);

	System.out.println(obj.toString());



Chapter 10 Input and Output


Java two sets of classes for reading/writing.

***) "Stream" section of package java.io for BYTES (reading/writing)

old language may assume that a byte (8-bits) is same as "character" (letter, digit)  <== the author was talking about ASCII (256 chars in total 2^7) encoding here     

***) Java for Internationalization,  UTF-8 (2^15 ? two-bytes, 16-bits)
     Unicode

		 Java and XML allows Unicode, so that we can read and write human languages.

		 Use "Writer/Reader", not "Stream", for textual data;


     converting Unicode strings to external files

     using "Reader/Writer", instead of "InputStream/OutputStream",  <== 




10.1 Reading standard input


a) read 1 byte from system input
  
	 int b = System.in.read();

b) To read a value of a known type, from standard input, using Scanner class

   Scanner sc = Scanner.create(System.in);

	 int i = sc.nextInt();


c) use Reader class to get Multiple-Encodings

   read lines of characters, using BufferedReader

***)  Writer

   BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	 String line;

	 while( (line = br.readLine()) != null) {
	   System.out.println(line);
	 }



10.2  Reading from Console or Controlling Terminal --  reading passwords without echoing

  System.console()    // can return NULL

	String name = System.console().readLine("name?");

	// Read passwords without echoing;  using Console class
	char[] pwd = null;
	Console cl = System.console();

  if (cl != null) {
	  try {
	    pwd = cl.readPassword("Password:");

			// can send the pwd to downstream for security check
			System.out.println("pwd is: " + new String(pwd));

    } finally {

		  // clear the memory for security reason
			if (pwd != null) {
			  java.util.Arrays.fill(pwd, ' ');
			}
		}


	  
10.3  Writing standard output or standard error

1) System.out is PrintStream connected to "standard out"
2) System.err is PrintStream connected to "standard error"

3) PrintWriter has similar methods as PrintStream
 
   PrintWriter pw = new PrintWriter(System.out);
	 pw.println("answer: ");


10.5 StreamTokenizer

  StringTokenizer st = new StringTokenizer("john@gmail.com", "@", true);

  String user = (String) st.nextElement();		// alas, need to cast
	String host = (String) st.nextElement();


10.6  Scanning input with Scanner Class


  Scanner, modeling C's scanf(),  but also has functionality of StreamTokenizer,
	  yet still need to be aware of the type of token, hence hasNextByte() and nextByte() etc methods.


		String dt = "25 Dec 2019";

		try(Scanner sdt = new Scanner(dt)) {
		  int d = sdt.nextInt();
			String m = sdt.next();
			int y = sdt.nextInt();
		}


10.7 Scanning input with Grammatical Structure

  1) StreamStokenizer and Scanner have limited number of tokens processed; but 

	2) "Parser generators" can do more; like C's yacc (Yet Another Compiler Compiler) and lex releases around 1970s.

	    "ANTLER"
			JavaCC (open source java.net)
			JParsec write parser in straight Java, all built at compile time. It's on GitHub now
			JFlex and CUP work together like yacc and lex.
			Parboiled uses "Parsing Expression Grammar" (PEG) to build parser at compile time, on GitHub
			Rats! parser generator is part of eXTensible Compiler Project at New York Univ
			Other compiler compiler, maintained at Java Source.

	Those "compiler geneartors" can be used to write "grammars" for a wide range of programs, from simple calculators, to HTML, full Java, C/C++ compilers.

	
	In simple application, "recursive descent parser" may be sufficient.



10.8  Opening a file by name


BufferedReader br = new BufferedReader(new FileReader("file.txt"));
BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("bytes.exe"));

InputStream is = new FileInputStream("input.txt");
OutputStream os = new FileOutputStream("output.txt");

byte[] bts = new byte[500];
int i;

while ((i = is.read(b)) != -1) {
 os.write(b, 0, i);
}

is.close();
os.close();


10.10 Reading a File into a String


10.11 Reassigning the standard streams

  System.in, System.out, System.err


***) sent standard errors to log file

	String logfile = "error.log";

	System.setErr(new PrintStream(new FileOutputStream(logfile)));

	// now create err stuff
	int a = new int[5];
	a[10] = 0;  // ArrayIndexOutOfBoundsException err which is written to error.log


***) send standard errors to standard out

  System.setErr(System.out);



10.12 Duplicating a Stream as it is written 



10.13 Reading/Writing a different character set

  InputStreamReader and OutputStreamWriters are used to convert text to/from Unicode

	BufferedReader fromJp = new BufferedReader(new InputStreamReader(new FileInputStream("jp.txt", "EUC_JP")));

	PrintWriter toSwedish = new PrintWriter(new OutputStreamWriter(new FileOutputStream("swedish.txt", "Cp278)));



10.14 handle pesky end-of-line characters

  \r , \n, or combined

	networking code ...



10.15 Platform-dependent file code

  

10.16 Reading "Continued" lines

  

10.17 Reading/Writing Binary Data

  ***)  DataInputStream or DataOutputStream


	String filenm = "input.txt";
	DataOutputStream os = new DataOutputstream(new FileOutputStream(filenm));

	int i = 3;
	double d = 0.5;

	os.writeInt(i);
	os.writeDouble(d);
	os.close();


10.18 Seeking to a position within a File

  ***) RandomAccessFile


  ReadRandom rr = new ReadRandom("input.txt");

	System.out.println("offset : " + r.readOffset());



	RandomAccessFile seeker = new RandomAccessFile("input.txt", "r");
	seeker.seek(0);    // move to the beginning
	seeker.readInt();  // read the offset

	seeker.seek(readOffset());
	seeker.readLine();



10.19 Writing data streams from C language


10.20 Saving and Restoring Java Objects

  ***) using ObjectInputStream and ObjectOutputStream


	  writeObject(), readObject() 


		public class MData implements Serializable {
		  private static final long serialVersionUID = 1L;

			private String name;

			private int age;

			.

			,
			,

		}

		
		ObjectOutputStream os = new ObjectOutputStream(new BuggeredOutputStream(
																											new FileOutputStream("out.txt)));

		os.writeObject(new MData("John", 33));

		os.close();


10.21 Serialization, prvent ClassCastExceptions with SerialVersionUID

  -->  CalssCastExceptions can be raised, if the Class (MData above) got updated and re-compiled, and then, not compatible ...

	
	when objects used in RMI (remote method invocation), or Servlets,  ...



   ***)  JDK tool  "serialver"  can check the UID for a class file.   (it's only meaningful to apply it on classes implementing Serializable interface)



10.22 Reading/Writing JAR or ZIP arhcives


  java.util.zip.ZipFile

	ZipEntry has getName(),  getInputStream(),  


	ZipFile zf = new ZipFile("input.zip");
	Enumeration all = zf.entries();
	while (all.hasMoreElements()) {
	  ZipEntry e = (ZipEntry) all.nextElement();

		if (e.isDirectory()) {
		  System.out.println("Directory: " + e.getName());
		} else {
		  System.out.println("File: " + e.getName());
		}

		.
		.
		.

	}


10.23 Finding files in a Filesystem-Neutral way with getResource() and getResourceAsStream()


   getClass(), getClassLoader(), getResource(), getResourceAsStream()


	 "Class", "ClassLoader" classes


	 public InputStream getResourceAsStream(String);

	 public URL getResource(String);

	 public Enumeration<URL> getResources(String) throws IOException;


	 --> locate "resource" or file on "classpath" ...


	 ^^ Need to check null value


10.24 Reading/Writing Compressed files

  GNU gzip/gunzip 

	// Java IO uses a lot of Decorator Design Pattern
	FileInputStream fis = new FileInputStream("input.txt");
	GZIPInputStream gzis = new GZIPInputStream(fis);
	InputStreamReader isr = new InputStreamReader(gzis);
	BufferedReader br = new BufferedReader(isr);

	String line;
	while ((line = br.readLine())) {
	  System.out.println("line: " + line);
	}



10.25 Communications API for Serial and Parallel Ports

  Peripheral devices, serial ports (RS232/434, COM, tty),  parallel (printer, LPT) ports

	USB (Universal Serial Bus)

	JSR-80 (Java Standards Request - 80) -- API accessing USB 

	java.comm API, 


	Communication API in NutShell 

	1) Abstract class - CommPort
	2) two subclasses - SerialPort and ParallelPort
	3) static factory CommPortIdentifier.getPortIdentifiers() -- list of ports, 
	4) CommPortIdentifier's open() method to receive CommPort object 


@SuppressWarnings("unchecked")
Enumeration<CommPortIdentifier> ports = CommPortIdentifier.getPortIdentifiers();

CommPortIdentifier cpi;
boolean atLeastOneSerialPresent = false;

while (ports.hasMoreElements()) {
  CommPortIdentifier pi = ports.nextElement();

	if (pi.getPortType() != CommportIdentifier.PORT_SERIAL) {
	  System.out.println("Not serial port: " + pi.getName());
		continue;
	}

	.
	.
	.

	// if found serial port
	CommPort cp = pi.open("something", time-out-numbers);
	SerialPort sp = (SerialPort) cp;
	sp.setSerialPortPamas(baud-rate_19200, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, 
																				 SerialPort.PARITY_NONE);

	// Once we get the Serial Port, we can open the inputstream from it
	InputStream is = new BufferedReader(new InputStreamReader(sp.getInputStream()));
	OutputStream os = new PrintStream(sp.getOutputStream(), true);


	// communication
	os.println("HELLO");
	String rspn = is.readLine();

	System.out.println("sent: HELLO" + ", got response: " + rspn);

	if (is != null) {
	  is.close();
	}
	if (os != null) {
	  os.close();
	}
}


***)  javacomm/CommPortOpen.java

      ParallelPrint
			CommPortModem
			CommPortDial
			TModem
			SerialLogger
			CommPortThreaded



10.26 Save User Data to Disk

 Five-step 

 1) create temp file, arrange for it to be removed automatically with deleteOnExit(true)
 2) write user data to the temp file, if any exceptions raised, the previous user data file is intact.
 3) delet eht backup file if exists
 4) rename user's previous file to *.bak
 5) rename the temp file to saved file.


 public class FileSaver {

	 private enum State { AVAILABLE, INSUE }

	 private State st;
	 private final File inf;
	 private final File tmpf;
	 private final File bkp;

	 public FileSaver(File input) {
	   inf = input;

		 tmpf = new File(inputFile.getAboslutePath() + ".tmp");
		 tmpf.createNewFile();
		 tmpf.deleteOnExit(true);

		 bkpf = new File(inf.getAbsolutePath() + ".bkp");

		 st = State.AVAILABLE;
	}



	10.27 Program: Text to PostScript

	   Note there is opensource Java PDF API ...




Chapter 23 Reflection -- gathering information from JVM

  java.lang.Class
	java.lang.reflect 


	1) load classes on the fly
	2) find methods and fields of a class
	3) construct a class from scratch (from an array of bytes) dynamically.


	***) JVM a large program, written in C/C++, implementing the Abstraction 

	***) "dyanmic loading" -- walk-up the tree of class hierarchy 

	    java -verbose MyClass    (which shows the dynamic loading)



23.1 Getting Class Description

  if type name is known at compile time, can get class instance using compiler keyword .class (also works for the either primitive types)

	Otherwise, java.lang.Object.getClass() will return Class object for the objet's class


	System.out.println("String class: " + String.class);

	System.out.println("Calendar.getInstance().getClass());


23.2 Finding and using Methods and Fields

  ***) java.lang.reflect



 JShell snippet :  


import java.lang.reflect.*;
import java.util.Arrays;
import java.util.List;

    try {
        Class<?> c = Class.forName("java.lang.String");

        List<Constructor<?>> ctors = Arrays.asList(c.getConstructors());
        ctors.forEach(e -> System.out.println(e.toString()));

        System.out.println("\n__________________________________\n");

        List<Method> mtds = Arrays.asList(c.getMethods());
        mtds.forEach(e -> System.out.println(e.toString()));

    } catch (Exception e) {
        e.printStackTrace();
    }




        // Cannot reflection FINAL fields ?
        // java.lang.IllegalArgumentException: Can not set final [B field java.lang.String.value to java.lang.Class
        // ^^^ https://stackoverflow.com/questions/3301635/change-private-static-final-field-using-java-reflection
        try {
            String sf = new String("checking reflection Fields");
            Class<?> cs = sf.getClass();

            List<Field> flds = Arrays.asList(cs.getDeclaredFields());

            flds.forEach(f -> {
                try {
                    Field modifiersField = Field.class.getDeclaredField("modifiers");
                    modifiersField.setAccessible(true);
                    modifiersField.setInt(f, f.getModifiers() & ~Modifier.FINAL);
                    f.setAccessible(true);
                    System.out.println(f + " : " + f.get(sf));
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                }
            });






BUT following works : 


class Test1 {
    private final String value;
    private final int hash;

    public Test1(String v, int h) {
        value = v;
        hash = h;
    }
}

        final Test1 t = new Test1("John", 33);
        Class<?> cs1 = t.getClass();
        List<Field> flds1 = Arrays.asList(cs1.getDeclaredFields());
        flds1.forEach(f -> {
            try {
                f.setAccessible(true);
//                System.out.println(f + " : " + f.get(cs));
                System.out.println(f.toGenericString() + " : " +  f.get(t));
            } catch (Exception e) {
                e.printStackTrace();
            }
        });



RESULT : 

private final java.lang.String REPL.$JShell$30$Test1.value : John
private final int REPL.$JShell$30$Test1.hash : 33



23.4 Loading and Instantiating a class dynamically


*** using class.forName("class-name") and class's newInstance() method

Class<String> sClazz = (Class<String>) Class.forName("java.lang.String");
String s = sClazz.newInstance();



23.5 Constructing a Class from Scratch with a ClassLoader

***) JVM has a built-in class loader
***) examine the URLClassLoader, to loadd class via internet
***) create own classloader, and use it


1) when write a class loader, loadClass() method needs to get the "class file" into a byte array (read the class file into byte array), 
2) convert the byte array into a Class object, and return the result


<=== book does not give example; 

// https://www.baeldung.com/java-classloaders
// This 5-blogs also helped get more information:  https://analyzejava.wordpress.com/2014/09/25/java-classloader-what-is-a-classloader/

1) Bootstrap class loader              <== implemented in C/C++
   parent of all other classloaders

	 can load java.lang.System, java.lang.Integer, etc

2) Extension Class Loader
   to load exntensions of the standard core Java classes

	 load classes from $JAVA_HOME/lib/ext

3) System Class Loader

   loads files found in CLASSPATH 


***) 


***) NoClassDefFoundError 
***) ClassNotFoundException

if classloader not able to find the class;  but what is the difference?


// will follow-up this post :  https://www.baeldung.com/java-classloaders


23.6 Performance Timing

System.currentTimeMillis()

JavaOne 2003 paper "Garbage Collection in the Java HotSpot Virtual Machine"

JavaOne 2007 talk by the same GC Development team "Garbage-Collection-Friendly Programming"

JavaOne 2010 "The Garbage Collection MythBusters"


23.7 Printing Class Information

  getFields() and getMethods() ...



23.8 Listing Classes in package

final Enumeration<URL> urls = Thread.currentThread()
																		.getContextClassLoader()
																		.getResources(pageName.replace(".", "/"));


23.9 Using and Defining Annotations (this is how JUnit was built)

***) apply annotations in code use @AnnotationName before class/method/field 

***) define annotations with @interface at the same level as class, interface etc.


1) public @interface IExpressAnnotation { } 

2) javac IExpressAnnotation

3) javap IExpressAnnotation  

   will display the following :

	 public interface IExpressAnnotation extends java.lang.annotation.Annotation {
}



***)  using javap to check Java Annotation class

javap java.lang.annotation.Annotation

javap java.lang.annotation.Annotation
Compiled from "Annotation.java"
public interface java.lang.annotation.Annotation {
  public abstract boolean equals(java.lang.Object);
  public abstract int hashCode();
  public abstract java.lang.String toString();
  public abstract java.lang.Class<? extends java.lang.annotation.Annotation> annotationType();
}



***) Annotation can be configured that compiler will only allow it in certain points in the code.


// Define annotation

@Target(ElementType.TYPE)              // only applies MyAnnotation to class/interface type
@Retention(RetentionPolicy.RUNTIME)    // MyAnnotation is preserved at Runtime 
public @interface MyAnnotation {
  public boolean fancy() default false;
	public int order() default 20;
}


// Using custom annotation
@MyAnnotation(fancy = true, order = 11)
@Resource(name = "Somestuff")
public class FancyOrderedStuff {
  Class<?> c = FancyOrderedStuff.class;

	System.out.println("Class " + c.getName() + " has following annotations: ");

	for (Annotation a : c.getAnnotations()) {
	  if (a instanceof MyAnnotation) {
		  MyAnnotation ma = (MyAnnotation) a;
			System.out.println("\t" + a + " with fancy=" + ma.fance() 
			                            + "and order=" + ma.order());
		} else {
		  System.out.println("\tdifferent annotation than MyAnnotation: " + a);
		}
	}
}




23.10 Finding Plug-in-like Classes via Annotations

<-- need to revisit 


23.11 

<-- need to revisit


























	   
