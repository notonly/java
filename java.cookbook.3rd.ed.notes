BattleShip (the classic naval combat game) <-- by MB (Milton Bradley ..

1.4 using CLASSPATH  effectively


java -classpath ~/example1/ex1.jar Example1

1) java interpreter looks dirs defined in CLASSPATH;

2) os tracing tool (trace, strace, truss, ktrace),  can see Java opens (or, stat, or access) the class file.

3) jdk class files,  in system props  (sun.boot.class.path)

4) jar file, unlike the single class file (using directory in classpath);  JAR file, needs to be in CLASSPATH defn

5) Web applications may NOT use bootpath or CLASSPATH;  those web apps having own ClassLoader, and set web app classpath to include WEB-INF/classes  (and the JAR files in WEB-INF/lib)

6) Create class files into CLASSPATH directories

   javac -d $HOME/classes Example1.java
	 java  -cp $HOME/classes/ pkg.Example1   (note, this command can be run from anywhere)


7) managing CLASSPATH in own env,

   set a base/main directory in $CLASSPATH
	 then make OPT_JARS including other JAR files or class-dirs;  and then adding them to $CLASSPATH


8)


1.5 Code Examples

   GitHub (https://github.com/IanDarwin/javasrcee)  

	 https://github.com/notonly/javasrc

	    javasrc
			darwinsys-api  (



1.9 Dealing with Deprecation Warnings

   javac -deprecation Example1.java

	 1) @Deprecated on method or class
	 2) @deprecated on javadoc

	 *) Rule of thumb:  if method/class is deprecated; NEW CODE should avoid using it.


1.10  check if we us  "System.properties"  for Runtime Debug (most likely NOT,  because, turn it on for RunTime requires rebooting the JVM.   We have re-load;  also some JMX stuff ... for updating the Log4J log level etc) ...

    if (System.getProperty("debug.fetch") != null) {
		    System.err.println("runtime debugging turned on");
		}

  java Example1   // will not see the debug

	java -Ddebug.fetch Example1   // will see the debugging, because the Runtime System.properties turned on, and code/class got the value


1.11  Correctness with Assertions


... Fast Forwarding ...

Chapter 9: Functional Programming

1) pure function, no side-effects, results depend only on their inputs and not on mutable state elsewhere in program
2) first-class function
3) Immutable data
4) extensive use of recusion and Lazy Evaluation


9.1 Using lambdas/closures in place of inner classes


My own notes:  how does Java implement (Java Compiler) handle closure -->  in the hood, still make closure to inner-class, and then some dynamic link (for groovy) type logic (vaguely remembered the Brian Goetz's presention ...


9.2 Using Predefined Interfaces, instead of own 

1) java.util.function package


interface Predicate<T> {
    boolean test(T t);
}


public List<Clazz> search(Predicate p);



9.3 simplifying processing with streams


1) production methods

2) passing methods (intermediate)  -- distinct, filter, limit, map, peek, sorted, unsorted

3) terminating methods -- count, findFirst, max, min, reduce, sum, collect ...



9.4 improving throughput with parallel streams and collections

<== no example from the book, just four bulletin-points


9.5 creating own functional interfaces

1) make sure just 1 non-default (or non-optional) method in that Interface; or

2) use @FunctionalInterface annotation 

   a.  define own functional interface

	      public interface MyFuncIntfc {
				    int computer(int x);
				}


				OR

				@FunctionalInterface
				public interface MyFuncIntfc {
				    int computer(int x);
				}

	 b.  apply it

	      public class ProcessInts {
				    static int[] ins = {0, 1, 2, 3};
						
						// THIS IS REALLY WHAT I NEED MORE USAGE ON THESE PATTERNS; (I more familiar with small closure usage) ...
						// Passing in the functions ... ;  and inside apply it
						static int doMath(int n, Function<Integer, Integer> func) {
						    return func.apply(n);
						}

			      public void static main(String[] args) {
							...
						}
				}




9.6 Using Existing Code as Functional with Method References   (Functional METHODS)  -->  MyClass::myFunc  ...

   If already have existing code matching a functional interface, and want to use it without renaming methods to match the interface name.


   Arrays.sort(names, String::compareToIgnoreCase);  // names array of {"a", "b", "d", "c"};

   Arrays.sort(names, String.CASE_INSENSITVIE_ORDER);  // the existing comparator


9.7 Java Mixins: Mixing in Methods 

1) what is mixin ? 

2) using "static import" feature to implement mixin 

     (cons:  static method, not instance method) 


3) pull method from Multiple Interfaces ....

   interface Bar {
	    default String filter(String s) {
				return "Filtered " + s;
	  }

		interface Foo {
			  default String convolve(String s) {
				  return "Convolved " + s;
		}



   public class MixinsDemo implements Foo, Bar {
	   ...

		 private String process(String s) {
		 	 return filter(convolve(s));  // methods mixed in
		 }
	 }




Alas,  this book finished Functional Programming in such a short chapter ....



Chapter 19 Processing JSON Data

19.1 creating JSON string, using StringBuilder


19.2 Parsing and Writing JSON with Jackson

  ObjectMapper 

	  mapper.writeValue(System.out, new Person("name", 33));


	  mapper.readValue(jsonInputStream,  Person.class);


19.3 Parsing and Writing JSON with org.json

  ? mid-size, widely used JSON API   -- This is also used in Android app


	// READ 

   JSONObject obj = new JSONObject(new JSONTokener(jsonInputStream));  // InputStream can come from file

	 System.out.println("name : " + obj.getString("name"));


	// WRITE
	JSONObject obj = new JSONObject();
	obj.put("name", "Ray");
	   .put("age", 33);

	System.out.println(obj.toString());



Chapter 10 Input and Output

10.1 Reading standard input



	  


