BattleShip (the classic naval combat game) <-- by MB (Milton Bradley ..

1.4 using CLASSPATH  effectively


java -classpath ~/example1/ex1.jar Example1

1) java interpreter looks dirs defined in CLASSPATH;

2) os tracing tool (trace, strace, truss, ktrace),  can see Java opens (or, stat, or access) the class file.

3) jdk class files,  in system props  (sun.boot.class.path)

4) jar file, unlike the single class file (using directory in classpath);  JAR file, needs to be in CLASSPATH defn

5) Web applications may NOT use bootpath or CLASSPATH;  those web apps having own ClassLoader, and set web app classpath to include WEB-INF/classes  (and the JAR files in WEB-INF/lib)

6) Create class files into CLASSPATH directories

   javac -d $HOME/classes Example1.java
	 java  -cp $HOME/classes/ pkg.Example1   (note, this command can be run from anywhere)


7) managing CLASSPATH in own env,

   set a base/main directory in $CLASSPATH
	 then make OPT_JARS including other JAR files or class-dirs;  and then adding them to $CLASSPATH


8)


1.5 Code Examples

   GitHub (https://github.com/IanDarwin/javasrcee)  

	 https://github.com/notonly/javasrc

	    javasrc
			darwinsys-api  (



1.9 Dealing with Deprecation Warnings

   javac -deprecation Example1.java

	 1) @Deprecated on method or class
	 2) @deprecated on javadoc

	 *) Rule of thumb:  if method/class is deprecated; NEW CODE should avoid using it.


1.10  check if we us  "System.properties"  for Runtime Debug (most likely NOT,  because, turn it on for RunTime requires rebooting the JVM.   We have re-load;  also some JMX stuff ... for updating the Log4J log level etc) ...

    if (System.getProperty("debug.fetch") != null) {
		    System.err.println("runtime debugging turned on");
		}

  java Example1   // will not see the debug

	java -Ddebug.fetch Example1   // will see the debugging, because the Runtime System.properties turned on, and code/class got the value


1.11  Correctness with Assertions


... Fast Forwarding ...

Chapter 9: Functional Programming

1) pure function, no side-effects, results depend only on their inputs and not on mutable state elsewhere in program
2) first-class function
3) Immutable data
4) extensive use of recusion and Lazy Evaluation


9.1 Using lambdas/closures in place of inner classes


My own notes:  how does Java implement (Java Compiler) handle closure -->  in the hood, still make closure to inner-class, and then some dynamic link (for groovy) type logic (vaguely remembered the Brian Goetz's presention ...


9.2 Using Predefined Interfaces, instead of own 

1) java.util.function package


interface Predicate<T> {
    boolean test(T t);
}


public List<Clazz> search(Predicate p);



9.3 simplifying processing with streams


1) production methods

2) passing methods (intermediate)  -- distinct, filter, limit, map, peek, sorted, unsorted

3) terminating methods -- count, findFirst, max, min, reduce, sum, collect ...



9.4 improving throughput with parallel streams and collections

<== no example from the book, just four bulletin-points


9.5 creating own functional interfaces

1) make sure just 1 non-default (or non-optional) method in that Interface; or

2) use @FunctionalInterface annotation 

   a.  define own functional interface

	      public interface MyFuncIntfc {
				    int computer(int x);
				}


				OR

				@FunctionalInterface
				public interface MyFuncIntfc {
				    int computer(int x);
				}

	 b.  apply it

	      public class ProcessInts {
				    static int[] ins = {0, 1, 2, 3};
						
						// THIS IS REALLY WHAT I NEED MORE USAGE ON THESE PATTERNS; (I more familiar with small closure usage) ...
						// Passing in the functions ... ;  and inside apply it
						static int doMath(int n, Function<Integer, Integer> func) {
						    return func.apply(n);
						}

			      public void static main(String[] args) {
							...
						}
				}




9.6 Using Existing Code as Functional with Method References   (Functional METHODS)  -->  MyClass::myFunc  ...

   If already have existing code matching a functional interface, and want to use it without renaming methods to match the interface name.


   Arrays.sort(names, String::compareToIgnoreCase);  // names array of {"a", "b", "d", "c"};

   Arrays.sort(names, String.CASE_INSENSITVIE_ORDER);  // the existing comparator


9.7 Java Mixins: Mixing in Methods 

1) what is mixin ? 

2) using "static import" feature to implement mixin 

     (cons:  static method, not instance method) 


3) pull method from Multiple Interfaces ....

   interface Bar {
	    default String filter(String s) {
				return "Filtered " + s;
	  }

		interface Foo {
			  default String convolve(String s) {
				  return "Convolved " + s;
		}



   public class MixinsDemo implements Foo, Bar {
	   ...

		 private String process(String s) {
		 	 return filter(convolve(s));  // methods mixed in
		 }
	 }




Alas,  this book finished Functional Programming in such a short chapter ....



Chapter 19 Processing JSON Data

19.1 creating JSON string, using StringBuilder


19.2 Parsing and Writing JSON with Jackson

  ObjectMapper 

	  mapper.writeValue(System.out, new Person("name", 33));


	  mapper.readValue(jsonInputStream,  Person.class);


19.3 Parsing and Writing JSON with org.json

  ? mid-size, widely used JSON API   -- This is also used in Android app


	// READ 

   JSONObject obj = new JSONObject(new JSONTokener(jsonInputStream));  // InputStream can come from file

	 System.out.println("name : " + obj.getString("name"));


	// WRITE
	JSONObject obj = new JSONObject();
	obj.put("name", "Ray");
	   .put("age", 33);

	System.out.println(obj.toString());



Chapter 10 Input and Output


Java two sets of classes for reading/writing.

***) "Stream" section of package java.io for BYTES (reading/writing)

old language may assume that a byte (8-bits) is same as "character" (letter, digit)  <== the author was talking about ASCII (256 chars in total 2^7) encoding here     

***) Java for Internationalization,  UTF-8 (2^15 ? two-bytes, 16-bits)
     Unicode

		 Java and XML allows Unicode, so that we can read and write human languages.

		 Use "Writer/Reader", not "Stream", for textual data;


     converting Unicode strings to external files

     using "Reader/Writer", instead of "InputStream/OutputStream",  <== 




10.1 Reading standard input


a) read 1 byte from system input
  
	 int b = System.in.read();

b) To read a value of a known type, from standard input, using Scanner class

   Scanner sc = Scanner.create(System.in);

	 int i = sc.nextInt();


c) use Reader class to get Multiple-Encodings

   read lines of characters, using BufferedReader

***)  Writer

   BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	 String line;

	 while( (line = br.readLine()) != null) {
	   System.out.println(line);
	 }



10.2  Reading from Console or Controlling Terminal --  reading passwords without echoing

  System.console()    // can return NULL

	String name = System.console().readLine("name?");

	// Read passwords without echoing;  using Console class
	char[] pwd = null;
	Console cl = System.console();

  if (cl != null) {
	  try {
	    pwd = cl.readPassword("Password:");

			// can send the pwd to downstream for security check
			System.out.println("pwd is: " + new String(pwd));

    } finally {

		  // clear the memory for security reason
			if (pwd != null) {
			  java.util.Arrays.fill(pwd, ' ');
			}
		}


	  
10.3  Writing standard output or standard error

1) System.out is PrintStream connected to "standard out"
2) System.err is PrintStream connected to "standard error"

3) PrintWriter has similar methods as PrintStream
 
   PrintWriter pw = new PrintWriter(System.out);
	 pw.println("answer: ");


10.5 StreamTokenizer

  StringTokenizer st = new StringTokenizer("john@gmail.com", "@", true);

  String user = (String) st.nextElement();		// alas, need to cast
	String host = (String) st.nextElement();


10.6  Scanning input with Scanner Class


  Scanner, modeling C's scanf(),  but also has functionality of StreamTokenizer,
	  yet still need to be aware of the type of token, hence hasNextByte() and nextByte() etc methods.


		String dt = "25 Dec 2019";

		try(Scanner sdt = new Scanner(dt)) {
		  int d = sdt.nextInt();
			String m = sdt.next();
			int y = sdt.nextInt();
		}







