

Chapter 2  lambda


1) lambda

  inventory.sort((Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight()));



2)	Functional Interface  (@FunctionalInterface)

    ^^ Only 1 abstract method.


		a.  Predicate<T>     --  test(...)


    b.  Consume<T>       --  accept(...)


		c.  Function<T, R>   --  apply(...)


		d.  Supplier<T>      --  () -> T


		e. UnaryOperator<T>  --   T -> T


		f. BinaryOperator<T> --  (T, T) -> T


		g. BiPredicate<T, U> -- (T, U) -> boolean


		h. BiConsumer<T, U>  -- (T, U) -> void


		i. BiFunction<T, U, R> -- (T, U) -> R




3.8 Useful methods to compose lambda expressions


  1) composing "Comparators"
	   
		 inventory.sort(comparing(Apple::getWeight).reversed());


		 ^^ Comparator.comparing static method returns a Comparator ...


		 ^^ Chaining comparactors

		    inventory.sort(comparing(Apple::getWeight)
				                 .reversed()
												 .thenComparing(Apple::getCountry)
				               );


  2) composing "Predicates"


     *** existing Predicate -- negate, and, or


		 Predicate<Apple> notRedApple = redApple.negate();   // here redApple is a Predicate


		 Predicate<Apple> redAndHeavyApple = redApple.and(apple -> apple.getWeight() > 150);

		 Predicate<Apple> redAndHeaveyAppleOrGreen 
		      = redApple.and(a -> a.getWeight() > 150).or(a -> GREEN.equals(a.getColor()));



  3) composing "Functions"

	   "Function" interface comes with two default methods, "andThen",  "compose",  both returns instance of "Funmction"


		 Function<Integer, Integer> plus1 = x -> x + 1;

		 Function<Integer, Integer> times2 = x -> x * 2;

		 Function<Integer, Integer> plus1AndThenTimes2 = plus1.andThen(times2);

		 Integer rslt = plus1AndThenTimes2.apply(2);   // rslt is:  (2 + 1) * 2 == 6

     ^^^ same as Math :   times2(plus1(x))


		 Now, how about plus1(times2(x))

		 Function<Integer, Integer> comp = plus1.compose(times2);    // 

		 Integer rslt = comp.apply(2);   // the result is  2 * 2 + 1 == 5



  4) similar ideas from mathematics 

	   a) integration :   

  





Chapter 5 Using Streams


  5.2 Slicing a stream 

	   *** slicking using a predicate

		   Java 9 added 2 new methods:  "takeWhile" -- lets you slice any stream (including infinite stream) using a "predicate",  and it stops once it has found an element that "fails" to match.

		List<Dish> slicedMenu1 = specialMenu.stream()
		                            .takeWhile(dish -> dish.getCalories() < 320)
																.collect(toList());



     "dropWhile" -- not taking elements matching the Predicate

		 List<Dish> menuWithCaloriesGreaterThan320 = specialMenu.stream()
		                            .dropWhile(dish -> dish.getCalories() < 320)
																.collect(toList());

		                
  5.2.2 Truncating a stream

	   using limit(3)  to truncate a stream


  5.2.3 Skipping elements

	   skip(2)  




  5.3 Mapping

	    1) applying a function to each element of a stream


			   map(String::length)


			2) "Flattening streams"   ***  <== need to DEPTH-FIRST !    *** Page-105


			   String[] words = {"Hello", "World"};

				 NOT-working one:  
				 
				     words.stream().map(word -> word.split("")).distinct().collect(Collectors.toList());

				 ^^ map(word -> word.split("")) created Stream<String[]>  ;   


				     the above returns List<String[]>  ,  instead of List<String>  (ie, the distinct characters fo the array of two words "Hello" and "World")



  			Correct way:

				    {"Hello", "World"}.stream()						// Stream<String>
									.map(word -> word.split(""))    // Stream<String[]>  due of word.split("")
									.flatMap(Arrays::stream)				// Stream<String>
									.distinct()											
									.collect(Collectors.toList());	// List<String>



       
			 *** another example

			   Given a list of numbers, how to return a list of the square of each number?  

				 [1, 2, 3, 4, 5]  ==> return [1, 4, 9, 16, 25]


				 Arrays.asList(1, 2, 3, 4, 5).stream()
				 														 .map(n -> n * n)
																		 .collect(Collectors.toList());



      
			 ^^^ Given 2 lists of numbers, return all pairs of numbers.   

				 List<Integer> nbr1 = [1, 2, 3]  and List<Integer> nbr2 = [5, 6]   
				 
				      ==>  (1, 5), (1, 6),  (2, 5), (2, 6),  (3, 5), (3, 6)


         List<int[]> pairs = nbr1.stream()
				                      .flatMap(i -> nbr2.stream()
															                  .map(j -> new int[]{i, j})
																			)
															.collect(toList());

				  



			^^^ extend previous example to return only pairs whose sum is divisible by 3


			    List<int[]> pairsDivisibleBy3 = nbr1.stream()
										.flatMap(i -> nbr2.stream()
																			.filter(j -> (i + j) % 3 == 0)
							                        .map(j -> new int[]{i, j})
														)
										.collect(toList());



  5.4 Finding and matching

	    "allMatch(Predicate<T>)"

      "anyMatch"

			"noneMatch"

			"findFirst"

			"findAny"



	*** Optional in a nutshell


	    "isPresent()"  returns true if Optional contains a value

			"ifPresent(Consumer<T> block)"   if Optional contains a value, and then consume such a value

			"T get()"  returns the value if present; otherwise throws NoSuchElementException

			"T orElse(T other)"  returns the value if present;  otherwise returns "default" value




  5.5 Reducing


	 1) sum


	   int sumOneToTen = IntStream.rangeClosed(1, 10).reduce(0, (a, b) -> a + b);

		 or

		 int sumOneToTen = IntStream.range(1, 11).reduce(0, Integer::sum);



    *** "no initial value"  -- returns Optional 

		 Optional<Integer> sum = IntStream.range(1, 11).reduce(Integer::sum);

		 ^^ if stream does not have elements,  and then, no sum will be returned, but just an Optional



  2) Max and min


	   Optional<Integer> max = IntStream.range(1, 11).reduce(Integer::max);   // again, no init values,  return Optional


		 ^^ min will using Integer::min function



  5.6 Summary


	   Intermediate and terminal operations


		 Operation        Type      Return Type   Type/Functional used      Function descriptior
    ------------      -------   -----------      ----------------         ------------------

		  filter          interm.    Stream<T>       Predicate<T>             T -> boolean

			distinct        interm.    Stream<T>       n/a                      n/a
                     (stateful/unbounded)

			takeWhile       interm.    Stream<T>       Predicate<T>             T -> boolean

			dropWhile       interm     Stream<T>       Predicate<T>             T -> boolean

			skip            interm.    Stream<T>       long                     n/a

			limit           interm.    Stream<T>       long                     n/a

			map             interm.    Stream<R>       Function<T, R>           T -> R

			flatMap         interm.    Stream<R>       Function<T, Stream<R>>   T -> Stream<R>

			sorted          interm.    Stream<T>       Comparator<T>            (T, T) -> int
                     (stateful/unbounded)

			anyMatch        Terminal   boolean         Predicate<T>             T -> boolean

			noneMatch       Terminal   boolean         Predicate<T>             T -> boolean

			allMatch        Terminal   boolean         Predicate<T>             T -> boolean

			findAny         Terminal   Optional<T>     n/a                      n/a

			findFirst       Terminal   Optional<T>     n/a                      n/a

			forEach         interm.    void            Consumer<T>              T -> void

			collect         Terminal   R               Collector<T, A, R>       n/a

			reduce          Terminal   Optional<T>     BinaryOperator<T>        (T, T) -> T
                     (stateful/unbounded)

      count           Terminal   long            n/a                      n/a




 5.7 Practicing

     List<Transaction> tr2011 = transactions.stream()
		      .filter(x -> x.getYear() == 2011)
					.sort(Comparator.comparing(Transaction::getValue))
					.collect(Collectors.toList());




  1)  Numeric streams

	   int calories = menu.stream().map(Dish::getCalories)
		                    .sum();


     ** "mapping to a numeric stream"

		    menu.stream()
				    .mapToInt(Dish::getCalories)
						.sum();


    ** "converting back to a stream of objects"

		  IntStream iStrm = menu.stream().mapToInt(Dish::getCalories);
			
			Stream<Integer> strm = iStrm.boxed();



    ** "Default values: OptionalInt"

		   OptionalInt maxCal = menu.stream().mapToInt(Dish::getCalories)
			                          .max();


			int maxCal2 = maxCl.orElse(1);



   
  5.8 Building Streams

	    1) streams from values : Stream.of

			  Stream<String> strm = Stream.of("hello", "world", "from");
				strm.map(String::toUpperCase).forEach(System.out::println);


      2) stream from nullable : ofNullable

			   Stream<String> strm = Stream.ofNullable(System.getProperty("home"));



     3) streams from arrays

		     Arrays.stream(new int[] {1, 2, 3, 4}).sum();


		 4) streams from "files"


		    long uniqueWords = 0;

				try (Stream<String> lines = Files.lines(Paths.get("data.txt"), Charset.defaultCharset())) {
				    uniqueWords = lines.flatMap(line -> Arrays.stream(line.split(" ")))
						                   .distint()
															 .count();
				} catch (IOException ignorable) {
				}




     5) streams from functions: creating infinite streams


		    Stream.iterate(0, n -> n + 2)
				      .limit(10)
							.forEach(System.out::println);



    6) Generate

		   Stream.generate(Math::random)
			       .limit(5)
						 .forEach(System.out::println);


       IntStream ones = IntStream.generate(() -> 1);




Chapter 6 Collecting data with Streams


  6.1 Collectors in a netshell

	  6.1.1 Collectors as advanced reductions 

		  
		6.1.2  Predfined collectors


  6.2 Reducing and summarizing

	   long nbr = menu.stream().collect(Collectors.counting());

		 or

		 nbr = menu.stream().count();


		 ***  java.util.stream.Collectors.*;


	 6.2.1  Collectors.maxBy,  minBy;  

	   Comparator<Dish> comparator1 = Comparator.comparingInt(Dish::getCalories);

		 Optional<Dish> mostCaloriesDish = menu.stream()
		             .collect(Collectors.maxBy(comparator1));



   6.2.2  Collectors.summingInt   
	        Collectors.averagingInt
					Collectors.summarizingInt ...




   6.2.3  Joining strings

	    menu.stream().map(Dish::getName).collect(Collectors.joining());



	 6.2.4  generalized summarization with reduction


	    int totalCal = menu.stream()
												 .collect(
													  Collectors.reducing(0, Dish::getCaloeries, 
																													 (i, j) -> i + j));

	        
        Collectors.reducing(....)

				    1st argument: starting value of the reduction operation
						2nd argument: the function to get value for each element
						3rd argument: BinaryOperator aggregates 2 items into a single value of the same type
						                (T, T) -> T    ;   BinaryOperator(T)


            1st argument -- "initial value"
						2nd argument -- Transformation function
						3rd argument -- Aggregating function   : like  Integer::sum  ;  or  (i, j) -> i + j




  6.3 Grouping

	  Map<Dish.Type, List<Dish>> dishesByType = menu.stream()
		                                              .collect(Collectors.groupingBy(Dish::getType));


    Map<CaloricLevel, List<Dish>> dishesByCal = menu.stream()
							.collect(Collectors.groupingBy(
								 dish -> {
								    if (dish.getCalories() <= 400) return CaloricLevel.DIET;
										else if (dish.getCalories() <= 700) return CaloricLevel.NORMAL;
										else return CaloricLevel.FAT;
									}));



   6.3.1 Manipulating grouped elements

	    Map<Dish.Type, List<Dish>> caloricDishesByType 
			  = menu.stream()
				    .collect(Collectors.groupingBy(Dish::getType, 
						                                Collectors.filtering(dish -> dish.getCalories() > 500, toList())));




     Map<Dish.Type, List<String>> dishNamesByType 
		    = menu.stream()
				   .collect(Collectors.groupingBy(Dish::getType, 
					              Collectors.mapping(Dish::getName, toList())));
																									   

     Map<Dish.Type, List<String>> dishNamesByType 
		    = menu.stream()
				   .collect(Collectors.groupingBy(Dish::getType, 
					            Collectors.flatMapping(dish -> dishTages.get( dish.getName() ).stream(), toSet())));


