

Chapter 2  lambda


1) lambda

  inventory.sort((Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight()));



2)	Functional Interface  (@FunctionalInterface)

    ^^ Only 1 abstract method.


		a.  Predicate<T>     --  test(...)


    b.  Consume<T>       --  accept(...)


		c.  Function<T, R>   --  apply(...)


		d.  Supplier<T>      --  () -> T


		e. UnaryOperator<T>  --   T -> T


		f. BinaryOperator<T> --  (T, T) -> T


		g. BiPredicate<T, U> -- (T, U) -> boolean


		h. BiConsumer<T, U>  -- (T, U) -> void


		i. BiFunction<T, U, R> -- (T, U) -> R




3.8 Useful methods to compose lambda expressions


  1) composing "Comparators"
	   
		 inventory.sort(comparing(Apple::getWeight).reversed());


		 ^^ Comparator.comparing static method returns a Comparator ...


		 ^^ Chaining comparactors

		    inventory.sort(comparing(Apple::getWeight)
				                 .reversed()
												 .thenComparing(Apple::getCountry)
				               );


  2) composing "Predicates"


     *** existing Predicate -- negate, and, or


		 Predicate<Apple> notRedApple = redApple.negate();   // here redApple is a Predicate


		 Predicate<Apple> redAndHeavyApple = redApple.and(apple -> apple.getWeight() > 150);

		 Predicate<Apple> redAndHeaveyAppleOrGreen 
		      = redApple.and(a -> a.getWeight() > 150).or(a -> GREEN.equals(a.getColor()));



  3) composing "Functions"

	   "Function" interface comes with two default methods, "andThen",  "compose",  both returns instance of "Funmction"


		 Function<Integer, Integer> plus1 = x -> x + 1;

		 Function<Integer, Integer> times2 = x -> x * 2;

		 Function<Integer, Integer> plus1AndThenTimes2 = plus1.andThen(times2);

		 Integer rslt = plus1AndThenTimes2.apply(2);   // rslt is:  (2 + 1) * 2 == 6

     ^^^ same as Math :   times2(plus1(x))


		 Now, how about plus1(times2(x))

		 Function<Integer, Integer> comp = plus1.compose(times2);    // 

		 Integer rslt = comp.apply(2);   // the result is  2 * 2 + 1 == 5



  4) similar ideas from mathematics 

	   a) integration :   

  





Chapter 5 Using Streams


  5.2 Slicing a stream 

	   *** slicking using a predicate

		   Java 9 added 2 new methods:  "takeWhile" -- lets you slice any stream (including infinite stream) using a "predicate",  and it stops once it has found an element that "fails" to match.

		List<Dish> slicedMenu1 = specialMenu.stream()
		                            .takeWhile(dish -> dish.getCalories() < 320)
																.collect(toList());



     "dropWhile" -- not taking elements matching the Predicate

		 List<Dish> menuWithCaloriesGreaterThan320 = specialMenu.stream()
		                            .dropWhile(dish -> dish.getCalories() < 320)
																.collect(toList());

		                
  5.2.2 Truncating a stream

	   using limit(3)  to truncate a stream


  5.2.3 Skipping elements

	   skip(2)  




  5.3 Mapping

	    1) applying a function to each element of a stream


			   map(String::length)


			2) "Flattening streams"   ***  <== need to DEPTH-FIRST !    *** Page-105


			   String[] words = {"Hello", "World"};

				 NOT-working one:  
				 
				     words.stream().map(word -> word.split("")).distinct().collect(Collectors.toList());

				 ^^ map(word -> word.split("")) created Stream<String[]>  ;   


				     the above returns List<String[]>  ,  instead of List<String>  (ie, the distinct characters fo the array of two words "Hello" and "World")



  			Correct way:

				    {"Hello", "World"}.stream()						// Stream<String>
									.map(word -> word.split(""))    // Stream<String[]>  due of word.split("")
									.flatMap(Arrays::stream)				// Stream<String>
									.distinct()											
									.collect(Collectors.toList());	// List<String>



       
			 *** another example

			   Given a list of numbers, how to return a list of the square of each number?  

				 [1, 2, 3, 4, 5]  ==> return [1, 4, 9, 16, 25]


				 Arrays.asList(1, 2, 3, 4, 5).stream()
				 														 .map(n -> n * n)
																		 .collect(Collectors.toList());



      
			 ^^^ Given 2 lists of numbers, return all pairs of numbers.   

				 List<Integer> nbr1 = [1, 2, 3]  and List<Integer> nbr2 = [5, 6]   
				 
				      ==>  (1, 5), (1, 6),  (2, 5), (2, 6),  (3, 5), (3, 6)


         List<int[]> pairs = nbr1.stream()
				                      .flatMap(i -> nbr2.stream()
															                  .map(j -> new int[]{i, j})
																			)
															.collect(toList());

				  



			^^^ extend previous example to return only pairs whose sum is divisible by 3


			    List<int[]> pairsDivisibleBy3 = nbr1.stream()
										.flatMap(i -> nbr2.stream()
																			.filter(j -> (i + j) % 3 == 0)
							                        .map(j -> new int[]{i, j})
														)
										.collect(toList());



  5.4 Finding and matching

	    "allMatch(Predicate<T>)"

      "anyMatch"

			"noneMatch"

			"findFirst"

			"findAny"



	*** Optional in a nutshell


	    "isPresent()"  returns true if Optional contains a value

			"ifPresent(Consumer<T> block)"   if Optional contains a value, and then consume such a value

			"T get()"  returns the value if present; otherwise throws NoSuchElementException

			"T orElse(T other)"  returns the value if present;  otherwise returns "default" value




  5.5 Reducing


	 1) sum


	   int sumOneToTen = IntStream.rangeClosed(1, 10).reduce(0, (a, b) -> a + b);

		 or

		 int sumOneToTen = IntStream.range(1, 11).reduce(0, Integer::sum);



    *** "no initial value"  -- returns Optional 

		 Optional<Integer> sum = IntStream.range(1, 11).reduce(Integer::sum);

		 ^^ if stream does not have elements,  and then, no sum will be returned, but just an Optional



  2) Max and min


	   Optional<Integer> max = IntStream.range(1, 11).reduce(Integer::max);   // again, no init values,  return Optional


		 ^^ min will using Integer::min function



  5.6 Summary


	   Intermediate and terminal operations


		 Operation        Type      Return Type   Type/Functional used      Function descriptior
    ------------      -------   -----------      ----------------         ------------------

		  filter          interm.    Stream<T>       Predicate<T>             T -> boolean

			distinct        interm.    Stream<T>       n/a                      n/a
                     (stateful/unbounded)

			takeWhile       interm.    Stream<T>       Predicate<T>             T -> boolean

			dropWhile       interm     Stream<T>       Predicate<T>             T -> boolean

			skip            interm.    Stream<T>       long                     n/a

			limit           interm.    Stream<T>       long                     n/a

			map             interm.    Stream<R>       Function<T, R>           T -> R

			flatMap         interm.    Stream<R>       Function<T, Stream<R>>   T -> Stream<R>

			sorted          interm.    Stream<T>       Comparator<T>            (T, T) -> int
                     (stateful/unbounded)

			anyMatch        Terminal   boolean         Predicate<T>             T -> boolean

			noneMatch       Terminal   boolean         Predicate<T>             T -> boolean

			allMatch        Terminal   boolean         Predicate<T>             T -> boolean

			findAny         Terminal   Optional<T>     n/a                      n/a

			findFirst       Terminal   Optional<T>     n/a                      n/a

			forEach         interm.    void            Consumer<T>              T -> void

			collect         Terminal   R               Collector<T, A, R>       n/a

			reduce          Terminal   Optional<T>     BinaryOperator<T>        (T, T) -> T
                     (stateful/unbounded)

      count           Terminal   long            n/a                      n/a




 5.7 Practicing

     List<Transaction> tr2011 = transactions.stream()
		      .filter(x -> x.getYear() == 2011)
					.sort(Comparator.comparing(Transaction::getValue))
					.collect(Collectors.toList());




  1)  Numeric streams

	   int calories = menu.stream().map(Dish::getCalories)
		                    .sum();


     ** "mapping to a numeric stream"

		    menu.stream()
				    .mapToInt(Dish::getCalories)
						.sum();


    ** "converting back to a stream of objects"

		  IntStream iStrm = menu.stream().mapToInt(Dish::getCalories);
			
			Stream<Integer> strm = iStrm.boxed();



    ** "Default values: OptionalInt"

		   OptionalInt maxCal = menu.stream().mapToInt(Dish::getCalories)
			                          .max();


			int maxCal2 = maxCl.orElse(1);



   
  5.8 Building Streams

	    1) streams from values : Stream.of

			  Stream<String> strm = Stream.of("hello", "world", "from");
				strm.map(String::toUpperCase).forEach(System.out::println);


      2) stream from nullable : ofNullable

			   Stream<String> strm = Stream.ofNullable(System.getProperty("home"));



     3) streams from arrays

		     Arrays.stream(new int[] {1, 2, 3, 4}).sum();


		 4) streams from "files"


		    long uniqueWords = 0;

				try (Stream<String> lines = Files.lines(Paths.get("data.txt"), Charset.defaultCharset())) {
				    uniqueWords = lines.flatMap(line -> Arrays.stream(line.split(" ")))
						                   .distint()
															 .count();
				} catch (IOException ignorable) {
				}




     5) streams from functions: creating infinite streams


		    Stream.iterate(0, n -> n + 2)
				      .limit(10)
							.forEach(System.out::println);



    6) Generate

		   Stream.generate(Math::random)
			       .limit(5)
						 .forEach(System.out::println);


       IntStream ones = IntStream.generate(() -> 1);




Chapter 6 Collecting data with Streams


  6.1 Collectors in a netshell

	  6.1.1 Collectors as advanced reductions 

		  
		6.1.2  Predfined collectors


  6.2 Reducing and summarizing

	   long nbr = menu.stream().collect(Collectors.counting());

		 or

		 nbr = menu.stream().count();


		 ***  java.util.stream.Collectors.*;


	 6.2.1  Collectors.maxBy,  minBy;  

	   Comparator<Dish> comparator1 = Comparator.comparingInt(Dish::getCalories);

		 Optional<Dish> mostCaloriesDish = menu.stream()
		             .collect(Collectors.maxBy(comparator1));



   6.2.2  Collectors.summingInt   
	        Collectors.averagingInt
					Collectors.summarizingInt ...




   6.2.3  Joining strings

	    menu.stream().map(Dish::getName).collect(Collectors.joining());



	 6.2.4  generalized summarization with reduction


	    int totalCal = menu.stream()
												 .collect(
													  Collectors.reducing(0, Dish::getCaloeries, 
																													 (i, j) -> i + j));

	        
        Collectors.reducing(....)

				    1st argument: starting value of the reduction operation
						2nd argument: the function to get value for each element
						3rd argument: BinaryOperator aggregates 2 items into a single value of the same type
						                (T, T) -> T    ;   BinaryOperator(T)


            1st argument -- "initial value"
						2nd argument -- Transformation function
						3rd argument -- Aggregating function   : like  Integer::sum  ;  or  (i, j) -> i + j




  6.3 Grouping

	  Map<Dish.Type, List<Dish>> dishesByType = menu.stream()
		                                              .collect(Collectors.groupingBy(Dish::getType));


    Map<CaloricLevel, List<Dish>> dishesByCal = menu.stream()
							.collect(Collectors.groupingBy(
								 dish -> {
								    if (dish.getCalories() <= 400) return CaloricLevel.DIET;
										else if (dish.getCalories() <= 700) return CaloricLevel.NORMAL;
										else return CaloricLevel.FAT;
									}));



   6.3.1 Manipulating grouped elements

	    Map<Dish.Type, List<Dish>> caloricDishesByType 
			  = menu.stream()
				    .collect(Collectors.groupingBy(Dish::getType, 
						                                Collectors.filtering(dish -> dish.getCalories() > 500, toList())));




     Map<Dish.Type, List<String>> dishNamesByType 
		    = menu.stream()
				   .collect(Collectors.groupingBy(Dish::getType, 
					              Collectors.mapping(Dish::getName, toList())));
																									   

     Map<Dish.Type, List<String>> dishNamesByType 
		    = menu.stream()
				   .collect(Collectors.groupingBy(Dish::getType, 
					            Collectors.flatMapping(dish -> dishTages.get( dish.getName() ).stream(), toSet())));




   6.3.2  Multilevel grouping 


	 Map<Dish.Type, Map<CalricLevel, List<Dish>>> dishesByTypeCaloricLevel
	    = menu.stream().collect(
			    Collectors.groupingBy(Dish::getType,
					    Collectors.groupingBy(dish -> {
							    if (dish.getCalories() <= 400) return CaloricLevel.DIET;
							    if (dish.getCalories() <= 700) return CaloricLevel.NORMAL;
									else return CaloricLevel.FAT;
							})
					)
			);




   6.3.3 Collecting data in subgroups


      Map<Dish.Type, Long> typesCount 
			  = menu.stream().collect(Collectors.groupingBy(Dish::getType, counting()));



      Map<Dish.Type, Optional<Dish>> mostCaloricByType
			  = menu.stream().collect(groupingBy(Dish::getType, 
				                         maxBy(comparingInt(Dish::getCalories))));



      *** Collectors.collectingAndThen

			Map<Dish.Type, Dish> mostCaloricByType 
			  = menu.stream()
				   .collect(groupingBy(Dish::getType,   // classification function
					          collectingAndThen(
										   maxBy(comparingInt(Dish::getCalories)),  // wrapped collector
											 Optional::get)));   // Transformation function



      Collectors.groupingBy
			Collectors.mapping
			Collectors.flatMapping
			Collectors.collectingAndThen





   6.4 Partitioning


      Map<Boolean, List<Dish>> partitionedMenu
			  = menu.stream().collect(partitioningBy(Dish::isVegetarian));



      Map<Boolean, Map<Dish.Type, List<Dish>>> vegetarianDishesByType
			  = menu.stream().collect(
				     partitioningBy(Dish::isVegetarian,         // partitioning function
						                 grouping(Dish::getType))); // 2nd collector




      Map<Boolean, Dish> mostCaloricPartitionedByVegetarian
			  = menu.stream().collect(
				     partitioningBy(Dish::isVegetarian,
						                CollectingAndThen(
														    maxBy(comparingInt(Dish::getCalories)), Optional.get)));





  ***  main static factory methods of "Collectors" class

	   Factory method              Return type              Used to

		 toList                       List<T>                 Gather all the stream's items in list

		 toSet

		 toCollection


		 counting                      Long                    Count the # of items in the stream

		 summingInt                    Integer                 Sum val of items in the stream


		 averagingInt

		 summarizingInt

		 join                          String                  concat strings from toString on item


		 maxBy                         Optional<T>             max ele in the stream given comparator

		 minBy


		 reducing                      type by reduction opr   Reduce stream to a single value starting from an initial value used as accumulator and iteratively combining it with each item of the stream using "BinaryOperator"


		 collectingAndThen             type returned by xforming  Wrap antoher collector and apply a tranformation function to its result


		 groupingBy                   Map<K, List<T>>          Group items in the stream based on the value of one of their properties and use those values as keys in resulting map

		 partitioningBy               Map<Boolean, List<T>>     partition items in stream based on result of the application of a predicate to each of item.






  6.6 Developing own collector for better performance

	  ^^ need to check the code and revisit






Chapter 7  Parallel Streams 


   ^^ skipped, need to revisit 




Chapter 8 Collection API enhancements


 8.1.1  List factory

    List<String> abc = List.of("A", "B", "C");


 8.1.2  Set factory

    Set<String> abc = Set.of("a", "b", "c");


 8.1.3  Map factory

    Map<String, Integer> abc = Map.of("a", 1, "b", 2, "c", 3);

		Map<String. Integer> abcd = Map.ofEntries(Map.entry("a", 1),
		    Map.entry("b", 2), Map.entry("c", 3));



 8.2 "removeIf" removes element matching a predicate

     "replaceAll" replacing elements using a UnaryOperator function

		 "sort" 



		 *** note the ConcurrentModificationException  ;  when elements are removed while being accessed /read ; 


		    
   Some Interview Questions: 


	    PROBLEM CODE:

			   for (Transaction x : transactions) {
				   if (Character.isDigit(x.getReferenceCode().charAt(0))) {
							transactions.remove(x);				// Causing ConcurrentModificationException
						}
				 }



        ^^ under the hood, for-each loop uses an Iterator object,

				   so the above is more like :


				for (Iterator<Transaction> iter = transactions.iterator(); iter.hasNext(); ) {
				  Transaction x = iter.next();

					if (Character.isDigit(x.getReferencecode().charAt(0))) {
					  transactions.remove(x);
					}
				}



			To FIX the issue,  have to use the Iterator object "Explicitly" and call iterator's "remove" method

			  for (Iterator<Transaction> iter = transaction.iterator(); iter.hasNext(); ) {
				  Transaction x = iter.next();

					if (Character.isDigit(x.getReferenceCode().charAt(0))) {

					  iter.remove();      //  compared to the above,  this avoids ConcurrentModificationException

					}
				}



     *** The above is verbose to write;

		  Java 8 has "removeIf" 

			transactions.removeIf(x -> Character.isDigit(x.getReferenceCode().charAt(0)));



  8.2.2 "replaceAll"


	    referenceCodes.replaceAll(code -> Character.toUpperCase(code.charAt(0)) + code.substring(1));




  
	
	8.3  Working with Map


    8.3.1  "forEach"

		  Old-way

			   for (Map.Entry<String, Integer> entry : ageOfFriends.entrySet()) {
				   String friend = entry.getKey();
					 Integer age = entry.getValue();

					 ...
				 }


			Java 8 way:

			  ageOfFriends.forEach( (friend, age) -> System.out.println(friend +  " is " + age  + " years old"));



		8.3.2 "sorting"

		   
			 *** Entry.comparingByValue

			 *** Entry.comparingByKey 


			 ageOfFriends.entrySet()
			             .stream()
									 .sorted(Entry.comparingByValue())
									 .forEachOrdered(System.out::println);



    8.3.3  "getOrDefault"


		  ageOfFriends.getOrDefault("a", 33);



    8.3.4  Computer patterns


		  *** computeIfAbsent -- if there is no specified value for the given key (it's absent or null), calculate the "new value" by "using the key" and add it to the map.

			*** computeIfPresent -- if the specified "eky" is presnet, calculate a new value for it, and add to the map.

			*** computer -- calculates a new value for a given key and stores in the map.



     one of the uses for computeIfAbsent is for "caching information"


		 lines.forEach(line -> dataToHash.computeIfAbsent(line, this::calculateDigest));


   8.3.5  Remove patterns


	   favoriteMoviews.remove(key, value);



   8.3.6  Replacement patterns

	   favoriteMoviews.replaceAll((friend, moview) -> movie.toUpperCase());



   8.3.7 Merge -- takes a BiFunction to merge values that have a duplicate key.

	   Map<String, String> m = new HashMap<>();

	   favoriteMovie.ofEntry( (k, v) -> m.merge(k, v, (movie1, movie2) -> movie1 + " & " + movie2));



   8.4 Improved ConcurrentHashMap

	   * forEach
		 * reduce
		 * search


		 Map.Entry,  and (key, value) 


		 8.4.2 "Counting"

		 8.4.3 "Set views"





  







