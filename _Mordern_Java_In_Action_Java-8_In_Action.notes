

Chapter 2  lambda


1) lambda

  inventory.sort((Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight()));



2)	Functional Interface  (@FunctionalInterface)

    ^^ Only 1 abstract method.


		a.  Predicate<T>     --  test(...)


    b.  Consume<T>       --  accept(...)


		c.  Function<T, R>   --  apply(...)


		d.  Supplier<T>      --  () -> T


		e. UnaryOperator<T>  --   T -> T


		f. BinaryOperator<T> --  (T, T) -> T


		g. BiPredicate<T, U> -- (T, U) -> boolean


		h. BiConsumer<T, U>  -- (T, U) -> void


		i. BiFunction<T, U, R> -- (T, U) -> R




3.8 Useful methods to compose lambda expressions


  1) composing "Comparators"
	   
		 inventory.sort(comparing(Apple::getWeight).reversed());


		 ^^ Comparator.comparing static method returns a Comparator ...


		 ^^ Chaining comparactors

		    inventory.sort(comparing(Apple::getWeight)
				                 .reversed()
												 .thenComparing(Apple::getCountry)
				               );


  2) composing "Predicates"


     *** existing Predicate -- negate, and, or


		 Predicate<Apple> notRedApple = redApple.negate();   // here redApple is a Predicate


		 Predicate<Apple> redAndHeavyApple = redApple.and(apple -> apple.getWeight() > 150);

		 Predicate<Apple> redAndHeaveyAppleOrGreen 
		      = redApple.and(a -> a.getWeight() > 150).or(a -> GREEN.equals(a.getColor()));



  3) composing "Functions"

	   "Function" interface comes with two default methods, "andThen",  "compose",  both returns instance of "Funmction"


		 Function<Integer, Integer> plus1 = x -> x + 1;

		 Function<Integer, Integer> times2 = x -> x * 2;

		 Function<Integer, Integer> plus1AndThenTimes2 = plus1.andThen(times2);

		 Integer rslt = plus1AndThenTimes2.apply(2);   // rslt is:  (2 + 1) * 2 == 6

     ^^^ same as Math :   times2(plus1(x))


		 Now, how about plus1(times2(x))

		 Function<Integer, Integer> comp = plus1.compose(times2);    // 

		 Integer rslt = comp.apply(2);   // the result is  2 * 2 + 1 == 5



  4) similar ideas from mathematics 

	   a) integration :   

  





Chapter 5 Using Streams


  5.2 Slicing a stream 

	   *** slicking using a predicate

		   Java 9 added 2 new methods:  "takeWhile" -- lets you slice any stream (including infinite stream) using a "predicate",  and it stops once it has found an element that "fails" to match.

		List<Dish> slicedMenu1 = specialMenu.stream()
		                            .takeWhile(dish -> dish.getCalories() < 320)
																.collect(toList());



     "dropWhile" -- not taking elements matching the Predicate

		 List<Dish> menuWithCaloriesGreaterThan320 = specialMenu.stream()
		                            .dropWhile(dish -> dish.getCalories() < 320)
																.collect(toList());

		                
  5.2.2 Truncating a stream

	   using limit(3)  to truncate a stream


  5.2.3 Skipping elements

	   skip(2)  




  5.3 Mapping

	    1) applying a function to each element of a stream


			   map(String::length)


			2) "Flattening streams"   ***  <== need to DEPTH-FIRST !    *** Page-105


			   String[] words = {"Hello", "World"};

				 NOT-working one:  
				 
				     words.stream().map(word -> word.split("")).distinct().collect(Collectors.toList());

				 ^^ map(word -> word.split("")) created Stream<String[]>  ;   


				     the above returns List<String[]>  ,  instead of List<String>  (ie, the distinct characters fo the array of two words "Hello" and "World")



  			Correct way:

				    {"Hello", "World"}.stream()						// Stream<String>
									.map(word -> word.split(""))    // Stream<String[]>  due of word.split("")
									.flatMap(Arrays::stream)				// Stream<String>
									.distinct()											
									.collect(Collectors.toList());	// List<String>



       
			 *** another example

			   Given a list of numbers, how to return a list of the square of each number?  

				 [1, 2, 3, 4, 5]  ==> return [1, 4, 9, 16, 25]


				 Arrays.asList(1, 2, 3, 4, 5).stream()
				 														 .map(n -> n * n)
																		 .collect(Collectors.toList());



      
			 ^^^ Given 2 lists of numbers, return all pairs of numbers.   

				 List<Integer> nbr1 = [1, 2, 3]  and List<Integer> nbr2 = [5, 6]   
				 
				      ==>  (1, 5), (1, 6),  (2, 5), (2, 6),  (3, 5), (3, 6)


         List<int[]> pairs = nbr1.stream()
				                      .flatMap(i -> nbr2.stream()
															                  .map(j -> new int[]{i, j})
																			)
															.collect(toList());

				  



			^^^ extend previous example to return only pairs whose sum is divisible by 3


			    List<int[]> pairsDivisibleBy3 = nbr1.stream()
										.flatMap(i -> nbr2.stream()
																			.filter(j -> (i + j) % 3 == 0)
							                        .map(j -> new int[]{i, j})
														)
										.collect(toList());



  5.4 Finding and matching

	    "allMatch(Predicate<T>)"

      "anyMatch"

			"noneMatch"

			"findFirst"

			"findAny"



	*** Optional in a nutshell


	    "isPresent()"  returns true if Optional contains a value

			"ifPresent(Consumer<T> block)"   if Optional contains a value, and then consume such a value

			"T get()"  returns the value if present; otherwise throws NoSuchElementException

			"T orElse(T other)"  returns the value if present;  otherwise returns "default" value




  5.5 Reducing


	 1) sum


	   int sumOneToTen = IntStream.rangeClosed(1, 10).reduce(0, (a, b) -> a + b);

		 or

		 int sumOneToTen = IntStream.range(1, 11).reduce(0, Integer::sum);



    *** "no initial value"  -- returns Optional 

		 Optional<Integer> sum = IntStream.range(1, 11).reduce(Integer::sum);

		 ^^ if stream does not have elements,  and then, no sum will be returned, but just an Optional



  2) Max and min


	   Optional<Integer> max = IntStream.range(1, 11).reduce(Integer::max);   // again, no init values,  return Optional


		 ^^ min will using Integer::min function



  5.6 Summary


	   Intermediate and terminal operations


		 Operation        Type      Return Type   Type/Functional used      Function descriptior
    ------------      -------   -----------      ----------------         ------------------

		  filter          interm.    Stream<T>       Predicate<T>             T -> boolean

			distinct        interm.    Stream<T>       n/a                      n/a
                     (stateful/unbounded)

			takeWhile       interm.    Stream<T>       Predicate<T>             T -> boolean

			dropWhile       interm     Stream<T>       Predicate<T>             T -> boolean

			skip            interm.    Stream<T>       long                     n/a

			limit           interm.    Stream<T>       long                     n/a

			map             interm.    Stream<R>       Function<T, R>           T -> R

			flatMap         interm.    Stream<R>       Function<T, Stream<R>>   T -> Stream<R>

			sorted          interm.    Stream<T>       Comparator<T>            (T, T) -> int
                     (stateful/unbounded)

			anyMatch        Terminal   boolean         Predicate<T>             T -> boolean

			noneMatch       Terminal   boolean         Predicate<T>             T -> boolean

			allMatch        Terminal   boolean         Predicate<T>             T -> boolean

			findAny         Terminal   Optional<T>     n/a                      n/a

			findFirst       Terminal   Optional<T>     n/a                      n/a

			forEach         interm.    void            Consumer<T>              T -> void

			collect         Terminal   R               Collector<T, A, R>       n/a

			reduce          Terminal   Optional<T>     BinaryOperator<T>        (T, T) -> T
                     (stateful/unbounded)

      count           Terminal   long            n/a                      n/a




 5.7 Practicing

     List<Transaction> tr2011 = transactions.stream()
		      .filter(x -> x.getYear() == 2011)
					.sort(Comparator.comparing(Transaction::getValue))
					.collect(Collectors.toList());




  1)  Numeric streams

	   int calories = menu.stream().map(Dish::getCalories)
		                    .sum();


     ** "mapping to a numeric stream"

		    menu.stream()
				    .mapToInt(Dish::getCalories)
						.sum();


    ** "converting back to a stream of objects"

		  IntStream iStrm = menu.stream().mapToInt(Dish::getCalories);
			
			Stream<Integer> strm = iStrm.boxed();



    ** "Default values: OptionalInt"

		   OptionalInt maxCal = menu.stream().mapToInt(Dish::getCalories)
			                          .max();


			int maxCal2 = maxCl.orElse(1);



   
  5.8 Building Streams

	    1) streams from values : Stream.of

			  Stream<String> strm = Stream.of("hello", "world", "from");
				strm.map(String::toUpperCase).forEach(System.out::println);


      2) stream from nullable : ofNullable

			   Stream<String> strm = Stream.ofNullable(System.getProperty("home"));



     3) streams from arrays

		     Arrays.stream(new int[] {1, 2, 3, 4}).sum();


		 4) streams from "files"


		    long uniqueWords = 0;

				try (Stream<String> lines = Files.lines(Paths.get("data.txt"), Charset.defaultCharset())) {
				    uniqueWords = lines.flatMap(line -> Arrays.stream(line.split(" ")))
						                   .distint()
															 .count();
				} catch (IOException ignorable) {
				}




     5) streams from functions: creating infinite streams


		    Stream.iterate(0, n -> n + 2)
				      .limit(10)
							.forEach(System.out::println);



    6) Generate

		   Stream.generate(Math::random)
			       .limit(5)
						 .forEach(System.out::println);


       IntStream ones = IntStream.generate(() -> 1);




Chapter 6 Collecting data with Streams


  6.1 Collectors in a netshell

	  6.1.1 Collectors as advanced reductions 

		  
		6.1.2  Predfined collectors


  6.2 Reducing and summarizing

	   long nbr = menu.stream().collect(Collectors.counting());

		 or

		 nbr = menu.stream().count();


		 ***  java.util.stream.Collectors.*;


	 6.2.1  Collectors.maxBy,  minBy;  

	   Comparator<Dish> comparator1 = Comparator.comparingInt(Dish::getCalories);

		 Optional<Dish> mostCaloriesDish = menu.stream()
		             .collect(Collectors.maxBy(comparator1));



   6.2.2  Collectors.summingInt   
	        Collectors.averagingInt
					Collectors.summarizingInt ...




   6.2.3  Joining strings

	    menu.stream().map(Dish::getName).collect(Collectors.joining());



	 6.2.4  generalized summarization with reduction


	    int totalCal = menu.stream()
												 .collect(
													  Collectors.reducing(0, Dish::getCaloeries, 
																													 (i, j) -> i + j));

	        
        Collectors.reducing(....)

				    1st argument: starting value of the reduction operation
						2nd argument: the function to get value for each element
						3rd argument: BinaryOperator aggregates 2 items into a single value of the same type
						                (T, T) -> T    ;   BinaryOperator(T)


            1st argument -- "initial value"
						2nd argument -- Transformation function
						3rd argument -- Aggregating function   : like  Integer::sum  ;  or  (i, j) -> i + j




  6.3 Grouping

	  Map<Dish.Type, List<Dish>> dishesByType = menu.stream()
		                                              .collect(Collectors.groupingBy(Dish::getType));


    Map<CaloricLevel, List<Dish>> dishesByCal = menu.stream()
							.collect(Collectors.groupingBy(
								 dish -> {
								    if (dish.getCalories() <= 400) return CaloricLevel.DIET;
										else if (dish.getCalories() <= 700) return CaloricLevel.NORMAL;
										else return CaloricLevel.FAT;
									}));



   6.3.1 Manipulating grouped elements

	    Map<Dish.Type, List<Dish>> caloricDishesByType 
			  = menu.stream()
				    .collect(Collectors.groupingBy(Dish::getType, 
						                                Collectors.filtering(dish -> dish.getCalories() > 500, toList())));




     Map<Dish.Type, List<String>> dishNamesByType 
		    = menu.stream()
				   .collect(Collectors.groupingBy(Dish::getType, 
					              Collectors.mapping(Dish::getName, toList())));
																									   

     Map<Dish.Type, List<String>> dishNamesByType 
		    = menu.stream()
				   .collect(Collectors.groupingBy(Dish::getType, 
					            Collectors.flatMapping(dish -> dishTages.get( dish.getName() ).stream(), toSet())));




   6.3.2  Multilevel grouping 


	 Map<Dish.Type, Map<CalricLevel, List<Dish>>> dishesByTypeCaloricLevel
	    = menu.stream().collect(
			    Collectors.groupingBy(Dish::getType,
					    Collectors.groupingBy(dish -> {
							    if (dish.getCalories() <= 400) return CaloricLevel.DIET;
							    if (dish.getCalories() <= 700) return CaloricLevel.NORMAL;
									else return CaloricLevel.FAT;
							})
					)
			);




   6.3.3 Collecting data in subgroups


      Map<Dish.Type, Long> typesCount 
			  = menu.stream().collect(Collectors.groupingBy(Dish::getType, counting()));



      Map<Dish.Type, Optional<Dish>> mostCaloricByType
			  = menu.stream().collect(groupingBy(Dish::getType, 
				                         maxBy(comparingInt(Dish::getCalories))));



      *** Collectors.collectingAndThen

			Map<Dish.Type, Dish> mostCaloricByType 
			  = menu.stream()
				   .collect(groupingBy(Dish::getType,   // classification function
					          collectingAndThen(
										   maxBy(comparingInt(Dish::getCalories)),  // wrapped collector
											 Optional::get)));   // Transformation function



      Collectors.groupingBy
			Collectors.mapping
			Collectors.flatMapping
			Collectors.collectingAndThen





   6.4 Partitioning


      Map<Boolean, List<Dish>> partitionedMenu
			  = menu.stream().collect(partitioningBy(Dish::isVegetarian));



      Map<Boolean, Map<Dish.Type, List<Dish>>> vegetarianDishesByType
			  = menu.stream().collect(
				     partitioningBy(Dish::isVegetarian,         // partitioning function
						                 grouping(Dish::getType))); // 2nd collector




      Map<Boolean, Dish> mostCaloricPartitionedByVegetarian
			  = menu.stream().collect(
				     partitioningBy(Dish::isVegetarian,
						                CollectingAndThen(
														    maxBy(comparingInt(Dish::getCalories)), Optional.get)));





  ***  main static factory methods of "Collectors" class

	   Factory method              Return type              Used to

		 toList                       List<T>                 Gather all the stream's items in list

		 toSet

		 toCollection


		 counting                      Long                    Count the # of items in the stream

		 summingInt                    Integer                 Sum val of items in the stream


		 averagingInt

		 summarizingInt

		 join                          String                  concat strings from toString on item


		 maxBy                         Optional<T>             max ele in the stream given comparator

		 minBy


		 reducing                      type by reduction opr   Reduce stream to a single value starting from an initial value used as accumulator and iteratively combining it with each item of the stream using "BinaryOperator"


		 collectingAndThen             type returned by xforming  Wrap antoher collector and apply a tranformation function to its result


		 groupingBy                   Map<K, List<T>>          Group items in the stream based on the value of one of their properties and use those values as keys in resulting map

		 partitioningBy               Map<Boolean, List<T>>     partition items in stream based on result of the application of a predicate to each of item.






  6.6 Developing own collector for better performance

	  ^^ need to check the code and revisit






Chapter 7  Parallel Streams 


   ^^ skipped, need to revisit 




Chapter 8 Collection API enhancements


 8.1.1  List factory

    List<String> abc = List.of("A", "B", "C");


 8.1.2  Set factory

    Set<String> abc = Set.of("a", "b", "c");


 8.1.3  Map factory

    Map<String, Integer> abc = Map.of("a", 1, "b", 2, "c", 3);

		Map<String. Integer> abcd = Map.ofEntries(Map.entry("a", 1),
		    Map.entry("b", 2), Map.entry("c", 3));



 8.2 "removeIf" removes element matching a predicate

     "replaceAll" replacing elements using a UnaryOperator function

		 "sort" 



		 *** note the ConcurrentModificationException  ;  when elements are removed while being accessed /read ; 


		    
   Some Interview Questions: 


	    PROBLEM CODE:

			   for (Transaction x : transactions) {
				   if (Character.isDigit(x.getReferenceCode().charAt(0))) {
							transactions.remove(x);				// Causing ConcurrentModificationException
						}
				 }



        ^^ under the hood, for-each loop uses an Iterator object,

				   so the above is more like :


				for (Iterator<Transaction> iter = transactions.iterator(); iter.hasNext(); ) {
				  Transaction x = iter.next();

					if (Character.isDigit(x.getReferencecode().charAt(0))) {
					  transactions.remove(x);
					}
				}



			To FIX the issue,  have to use the Iterator object "Explicitly" and call iterator's "remove" method

			  for (Iterator<Transaction> iter = transaction.iterator(); iter.hasNext(); ) {
				  Transaction x = iter.next();

					if (Character.isDigit(x.getReferenceCode().charAt(0))) {

					  iter.remove();      //  compared to the above,  this avoids ConcurrentModificationException

					}
				}



     *** The above is verbose to write;

		  Java 8 has "removeIf" 

			transactions.removeIf(x -> Character.isDigit(x.getReferenceCode().charAt(0)));



  8.2.2 "replaceAll"


	    referenceCodes.replaceAll(code -> Character.toUpperCase(code.charAt(0)) + code.substring(1));




  
	
	8.3  Working with Map


    8.3.1  "forEach"

		  Old-way

			   for (Map.Entry<String, Integer> entry : ageOfFriends.entrySet()) {
				   String friend = entry.getKey();
					 Integer age = entry.getValue();

					 ...
				 }


			Java 8 way:

			  ageOfFriends.forEach( (friend, age) -> System.out.println(friend +  " is " + age  + " years old"));



		8.3.2 "sorting"

		   
			 *** Entry.comparingByValue

			 *** Entry.comparingByKey 


			 ageOfFriends.entrySet()
			             .stream()
									 .sorted(Entry.comparingByValue())
									 .forEachOrdered(System.out::println);



    8.3.3  "getOrDefault"


		  ageOfFriends.getOrDefault("a", 33);



    8.3.4  Computer patterns


		  *** computeIfAbsent -- if there is no specified value for the given key (it's absent or null), calculate the "new value" by "using the key" and add it to the map.

			*** computeIfPresent -- if the specified "eky" is presnet, calculate a new value for it, and add to the map.

			*** computer -- calculates a new value for a given key and stores in the map.



     one of the uses for computeIfAbsent is for "caching information"


		 lines.forEach(line -> dataToHash.computeIfAbsent(line, this::calculateDigest));


   8.3.5  Remove patterns


	   favoriteMoviews.remove(key, value);



   8.3.6  Replacement patterns

	   favoriteMoviews.replaceAll((friend, moview) -> movie.toUpperCase());



   8.3.7 Merge -- takes a BiFunction to merge values that have a duplicate key.

	   Map<String, String> m = new HashMap<>();

	   favoriteMovie.ofEntry( (k, v) -> m.merge(k, v, (movie1, movie2) -> movie1 + " & " + movie2));



   8.4 Improved ConcurrentHashMap

	   * forEach
		 * reduce
		 * search


		 Map.Entry,  and (key, value) 


		 8.4.2 "Counting"

		 8.4.3 "Set views"






Chapter 9  Refactoring, testing and debugging


    https://github.com/iluwatar/java-design-patterns/blob/master/strategy/src/main/java/com/iluwatar/strategy/App.java  

		^^ has conventional way of handling "Strategy Pattern", and the Java 8 way using Lambda expressions

		-->  https://java-design-patterns.com/patterns/strategy/   (the diagram and more)


  9.1.3  From lambda expression to method references

	  From:

		  Map<CaloricLevel, List<Dish>> dishesByCaloricLevel 
			  = menu.stream()
				   .collect(
					   groupingBy(dish -> {
						   if (dish.getCalories() <= 400) return CaloricLevel.DIET;
							 else if (dish.getCalories() <= 700) return CaloricLevel.NORMAL;
							 else return CaloricLevel.FAT;
						 }));


    To:

		   menu.stream()
			     .collect(groupingBy(Dish::getCaloricLevel));

			 where Dish's 

			  CaloricLevel getCaloricLevel(Dish dish) {
					 if (dish.getCalories() <= 400) return CaloricLevel.DIET;
					 else if (dish.getCalories() <= 700) return CaloricLevel.NORMAL;
					 else return CaloricLevel.FAT;
				}




   ===============
	    another example


    From:

			inventory.sort((Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight()));


		TO:
				  
			inventory.sort(Collectors.comparng(Apple::getWeight));




	=================

	  FROM:

		  int totalCal = menu.stream()
			                   .map(Dish::getCalories)
			                   .reduce(0, (c1, c2) -> c1 + c2);

    TO:

		    menu.stream().collect(Collectors.summingInt(Dish::getCalories));
  


  9.1.4 From Imperative data processing to Streams


	  List<String> dishNames 
		   = menu.stream()
			       .map(Dish::getName)
						 .collect(Collectors.toList());


  9.1.5 Improving code flexibility


    *** Adopting "Functional Interfaces"

		*** Conditional Deferered Execution

		in Java 8,

		   logger.log(Level.FINER, Supplier<String msgSupplier);


    The Java 8 internal implementation of log

     public void log(Level level, Supplier<String> msgSupplier) {
		   if (logger.isLoggable(level)) {
			   log(level, msgSupplier.get());
			 }
		 }


  

	  *** Execute Around

		  String oneLine = processFile((BufferedReader b) -> b.readLine());

			String twoLines = processFile(BufferedReader b) -> b.readLine() + b.readLine());

			public static String processFile(BufferedReaderProcessor p) throws IOException {
			  try (BufferedReader br = new BuffferedReader(new FileReader("myfile.txt"))) {
				  return p.process(br);
				}
			}

			public interface BufferedReaderProcessor {
			  String process(BufferedReader b) throws IOException;
			}



  9.2 Refactoring object-oriented design patterns with lambdas

	   *** Strategy
		 *** Template method
		 *** Observer
		 *** Chain of responsibility
		 *** Factory



==>  From the following examples (source code),  the Observer pattern is very similar to Strategy pattern,  the Observer pattern just went 1-level up by adding a container to hold several "clients"  (observers) in "Subject" ... 


		 9.1.2 Strategy  -- a family of algorithms and choose them at Runtime  

		       ^^^ Typical polymorphic ...   <-- using Interface ...

		   client -->  Strategy  <---  ConcreteStrategyA
			                       <---  ConcreteStrategyB


		   public interface ValidationStrategy {
			   boolean execute(String s);
			 }

			 public class IsAllLowerCase implements ValidationStrategy {
			   public boolean execute (String s) {
				   return s.matches("[a-z]+");
				 }
			 }


			 public class IsNumeric implements ValidationStrategy {
			   public boolean execute (String s) {
				   return s.matches("\\d+");
				 }
			 }


			 ========

			 public class Validator {
			   private final ValidationStrategy strategy;

				 public Validator (ValidationStrategy v) {
				   this.strategy = v;
				 }

				 public boolean validate(String s) {
				   return strategy.execute(s);
				 }
			 }


			 Validator numericValidator = new Validator(new IsNumeric());
			 boolean b1 = numericValidator.validate("abc");

			 Validator lowerCaseValidator = new Validator(new IsAllLowerCase());
			 boolean b2 = lowerCaseValidator.validate("abc");



      =========  Now, Java 8 way

			  ValidationStrategy is implicitly a "functional interface", and it has the same "function descriptor" as Predicate<String>

				Instead of declaring "new classes to implement different strategies, just pass lambda expression directly"


			 Validator numValidator = new Validator((String s) -> s.matches("\\d+"));
			 numValidator.execute("abc");

			 Validator lowerCaseValidator = new Validator(s -> s.matches("[a-z]+"));
			 lowerCaseValidator.execute("abc");



  9.2.2  Template method  -- this design pattern needed to represent outline of an algorithm and flexibility to change certain parts of it.

	      ^^ something like passing "functions" into methods ... 


	   abstract class OnlineBanking {
		   public vid processCustomer(int id) {
			   Customer c = Database.getCustomerWithId(id);
				 makeCustomerHappy(c);
			 }

			 abstract void makeCustomerHappy(Customer c);

		 }


		 different branches can provider different implementations of makeCustomerHappy method by subclassing the OnlineBanking class.


		 ================

		 using lambda expressions


		 public void processCustomer(int id, Consumer<Customer> makeCustomerHappy) {
		   Customer c = Database.getCustomerWithId(id);
			 makeCustomerHappy.apply(c);
		 }

		 new OnlineBankingLambda().processCustomer(12345, (Customer c) -> System.out.println("Hello " + c.getName()));


  9.2.3 Observer


	  subject               Observer          concreteObserverB
                                            concreteObserverA
		notifyObservers()      notfiy()     

	  

		interface Observer {
		  void notify (String s);
		}

		class NYTimes implements Observer {
		   public void notify(String msg) {
			   if (StringUtils.isNotBlank(msg) && msg.contains("money")) {
				   System.out.println("....");
				 }
			 }
		}

		class Guardian implements Observer {
		 .
		 . 
		 .
		}

		=====

		interface Subject {

		  void registerObserver (Observer o);
			void notifyObservers (String msg);
	  }

		class Feed implements Subject {
		   
			 private final List<Observer> obsvrs = new ArrayList<>();

			 public void registerObserver(Observer o) {
			   this.observers.add(o);
			 }

			 public void notifyObservers(String msg) {
			   obsvrs.forEach(Observer::notify);
			 }
		}


		Feed f = new Feed();
		f.registerObserver(new NYTimes());
		f.registerObserver(new Guardian());

		f.notifyObservers("....");


		=========================

		Using Java 8 Lambda ....

		   Instead of instantiaing 3 observer objects explicitly, can pass a lambda expression directly to represent the behavior to execute


			 f.registerObser((String msg) -> {
			     if (StringUtils.isNotBlank(msg) && msg.contains("money")) {
					   System.out.println("....");
					 });
			   
			 f.registerObser((String msg) -> {
			     if (StringUtils.isNotBlank(msg) && msg.contains("Guardian...")) {
					   System.out.println("....");
					 });
			   
		

   9.2.4  Chain of responsibility  -- to create a chain of processing objects (chain of operations);  it's implemented by defining an abstract class representing a processing object that defines a field to keep track of a successor.


	 public abstract class ProcessingObject<T> {
	   protected ProcessingObject<T> successor;

		 public void setSuccessor(ProcessingObject<T> successor) {
		   this.successor = successor;
		 }

		 public T handle(T input) {
		   T r = handleWork(input);

			 if (successor != null) {
			   return successor.handle(r);
			 }
		 }

		 abstract protected T handleWork(T input);

		}




		public class HeaderTextProcessing extends ProcessingObject<String> {
		  public String handleWork(String text) {
			  return "Added Header..."  + text;
			}
		}

		public class SpellCheckerProcessing extends ProcessingObject<String> {
		  public String handleWork(String text) {
			  return text.replaceAll("labda", "lambda");
			}
		}


		====


		ProcessingObject<String> p1 = new HeaderTextProcessing();
		ProcessingObject<String> p2 = new SpellCheckerTextProcessing();

    p1.setSuccessor(p2);
   
	  String rslt = p1.handle("This labda is new in Java 8");

		System.out.println(rslt);   // Added Header... This lambda is new in Java 8



		===============

		Java 8 way -- Using "Functional Interface" ...

    1)  this pattern looks like "chaining" functions;  composing lambda expression.  Use Function<String, String> to represent "ProcessingObject" ...,  or (more precisely) a UnaryOperator<String>.  

		    UnaryOperator extends Function interface;  BinaryOperator extends BiFunction interface

				a good blog on UnaryOperator and BinaryOperator ...


    2)  to "Chain" them,  use "andThen" method 


		UnaryOperator<String> headerProcessing = 
		    (String text) -> "Added Header..." + text;

		UnaryOperator<String> spellCheckerProcessing = 
		    (String text) -> text.replaceAll("labda", "lambda");


		Function<String, String> pipeline =
		    headerProcessing.andThen(spellCheckerProcessing);

		String result = pipeline.apply("This labda is new in Java 8");
		    



  9.2.5 Factory


	  public class ProductFactory {
		  public static Product createProduct(String name) {
			 switch (name) {
			   case "loan": return new Loan();
			   case "stock": return new Stock();
				 default: throw new RuntimeException("no such product " + name);
			 }
			}
		}


		Product p = ProductFactory.createProduct("loan");


		========

		using Java 8

		  using "method reference"


		Supplier<Product> loanSupplier = Loan::new;

		Loan loan = loanSupplier.get();


		Now, rewrite the above factory 

		final static Map<String, Product> products = Map.ofEntries(
			Map.entry("loan", Loan::new),
			Map.entry("stock", Stock::new)
		 );


		 public static Product createProduct(String name) {
		   Supplier<Product> p = map.get(name);

			 if (p != null) {
			   return p.get();
			 }

			 throw new IllegalArgumentException("no such product " + name);
		}




  9.3 Testing lambdas   <== the book did not give much information here


     Unit test ... 



  9.4 Debugging 


	   logging information


		 List<Integer> rslt =
		     numbers.stream()
				        .peek(x -> System.out.println("from stream: " + x))
								.map(x -> x + 17)
				        .peek(x -> System.out.println("after map: " + x))
								.collect(Collectors.toList());


	   


Chapter 10  Domain-specific languages using lambdas


  1) using inner class

	   Collections.sort(persons, new Comparator<Person>() {
		   public int compare(Person p1, Person p2) {
			    return p1.getAge() - p2.getAge();
			 }
		 }


	2) using lambda expression


	   Collections.sort(persons, 

		    (Person p1, Person p2) -> p1.getAge() - p2.getAge());


  3) using Collectors.comparing static method


	  Collections.sort(persons,
		     Collectors.comparing(p -> p.getAge()));


    Collections.sort(persons,
		     Collectors.comparing(Person::getAge));


  4) chaining

	   Collections.sort(persons,
		     Collectors.comparing(Person::getAge).reverse());


     Collections.sort(persons,
		     comparing(Person::getAge)
				    .thenComparing(Person::getName));



  5) streaming

	   List<String> errors = 
		   Files.lines(Paths.get("myfile.txt"))
			      .filter(line -> line.startsWith("ERROR"))
						.limit(40)
						.collect(toList());


  6) Collectors as a DSL to aggregate data

     Map<String, Map<Color, List<Car>>> carsByBrandAndColor
			 = cars.stream()
			       .collect(groupingBy(Car::getBrand,
						                      groupingBy(Car::getColor)));


     
		 Comparator<Person> comparator
		   = comparing(Person::getAge)
			      .thenComparing(Person::getName);



  7) Grouping collectors BUILDER

	  public class GroupingBuilder<T, D, K> {
		  private final Collector<? super T, ?, Map<K, D>> collector;

			private GroupingBuilder(Collector<? super T, ?, Map<K, D>> collector) {
			  this.collector = collector;
			}

			public Collector<? super T, ?, Map<K, D>> get() {
			  return collector;
			}

			public <J> GroupingBuilder<T, Map<K, D>, J>
			   after(Function<? super T, ? extends J> classifier) {
				   
				 return new Groupingbuilder<>(groupingBy(classifier, collector));
			}

			public static <T, D, K> GroupingBuilder<T, List<T>, K>
			   groupOn(Function<? super T, ? extends K> classifier) {

				 return new GroupingBuilder<>(groupingBy(classifier));
			}
		}


		Collector<? super Car, ?, Map<Brand, Map<Color, List<Car>>>>
		  carGroupingCollector = 
			   groupOn(Car::getColor)
				 .after(Car::getBrand)
				 .get();


  10.3  Patterns and techniques to create DSL in Java



  10.4  JOOQ -- an internal DSL that implements SQL as a type-safe embedded lang in Java



	   SQL :

		   select * from book
			 where BOOK.PUBLISHED_IN = 2018
			 order by BOOK.TITLE

		 
		 JOOQ :

		   create.selectFrom(BOOK)
			       .where(BOOK.PUBLISHED_IN.eq(2018))
						 .orderBy(BOOK.TITLE)


     =====
		   
			 selecting books from a data by using jooQ DSL

			 Class.forName("org.h2.Driver");

			 try (Connection c = 
			       getConnection("jdbc:h:~/sql-goodies-with-mapping", "sa", "")) {

						 DSL.using(c)
						    .select(BOOK.AUTHOR, BOOK.TITLE)
								.where(BOOK.PUBLISHED_IN.eq(2018))
							.orderBy(BOOK.TITLE)
							.fetch()
							.stream()
							.collect(groupingBy(
							   r -> r.getValue(BOOK.AUTHOR),
								   LinkedHashMap::new,
									 mapping(r -> r.getValue(BOOK.TITLE), toList()))
							.forEach((autho, titles) ->
							      System.out.println(author = " is author of " + titles));


   10.4.2  Cucumber   -- Behaviro-driven development (BDD)

	    ^^ the cucumber not used in current projects/comp



   10.4.3 Spring Integration

	   



Part 4  -- Everyday Java


Chapter 11  Using Optional 

  11.1.1  Reducing NullPointerException with defensive checking


  11.3  Patterns for adopting Optionals

	   
		 *** Creating Optional objects

		   Optional<Car> optCar = Optional.empty();

		  *** Optional from a non-null value

			  Optional<Car> optCar = Optional.of(car);

		 *** optional from null

		    Optional<Car> optCar = Optional.ofNullable(car);


   
	 ***  flatMap methods of "Stream" and "Optional"

	    
			// note the parameter  Optional
			public String getCarInsuranceName(Optional<Person> person) {
			  return person.flatMap(Person::getCar)
				             .flatMap(Car::getInsurance)
										 .map(Insurance::getName)
										 .orElse("Unknow");

	   
		  

		Stream<Optional<String>> stream = ....;

		Set<String> rslt = stream.filter(Optional::isPresent)
					.map(Optional::get)
					.collect(toSet());



  11.3.5  default actions and unwrapping an optional


	   1)  get()
		 2)  orElse(T other)
		 3)  orElseGet(Supplier<? extends T> other)
		 4)  or(Supplier<? extends Optional<? extends T>> supplier)
		 5)  orElseThrow(Supplier<? extends X> exceptionSupplier)
		 6)  ifPresent(Consume<? super T> consumer)

		 7)  Java 9 introducing:  

		     ifPresentOrElse(Consumer<? super T> action, Runnable emptyAction) -- differsfrom ifPresent by taking a Runnable ... 



  11.3.6 Combining two optionals 


	  Using combination of map and flatMap methods, to implement a method in a single statement and without writing any conditional constructs


		return persons.flatMap(person -> cars.map(car -> findCheapestInsurance(person, car)));


		Optional<Insurance> optionalInsurance = ...;

		optionalInsurance.filter(insurance -> "CambridgeInsurance".equals(insurance.getName()))
		                 .ifPresent(x -> System.out.println("ok"));




  ***  Methods of Optional class

	  1) empty  -- returns an empty Optional 

		2) filter -- if value present and matches the given predicate, returns this Optional; otherwise, returns the empty-Optional

		3) flatMap -- if a value if presnet, returns Optional resulting from the application of the provided mapping function to it;  otherwise, returns the empty Optional

		4) get -- if value present, retunr Optional of the value;  otherwise, throws NoSuchElementException 

		5) ifPresent -- iv value is present, the specified "consumer" is invoked with the value;  otherwise, doing nothing

		6) ifPresentOrElse -- similar to the above, but, when "no value / empty",  do something instead of nothing

    7) isPresent  -- 


		8) map  -- if a value is present, applies the provided mapping function to the value

		            what if NOT present?  ...


    9) of   -- returns an Optional wrapping the given value;  or throws NullPointerException if value is "null"


		10) ofNullable -- if value present, returns Optional wrapping the value;  otherwise, empty Optional if the value is "null"

		11) or  -- if value present, returns the same Optional;  otherwise, returns another Optional produced by the supplying function

		12) orElse -- returns the value if present;  otherwise, the given default value

		13) orElseGet -- returns the value if present; otherwise, returns the one provided by the gien "Supplier"

		14) orElseThrow -- returns the value if present; otherwise, throws the exception created by the given "Supplier"

		15) stream -- if a value is present, returns a stream containing only it;  otherwise, returns an "empty stream"




  11.4 Practical examples of using Optional


	  11.4.1 wrapping a potentially null value in an Optional

		  Optional<Object> value = Optional.ofNullable(map.get("key"));


    11.4.2 Exceptions vs Optional


		  public static Optional<Integer> stringToInt(String s) {
			  try {
				    return Optional.of(Integer.parseInt(s));
				} catch (NumberFormatException e) {
				    return Optional.empty();
				}
			}



    11.4.4 Putting it all together


		  public int readDurationFromProperty(Properties props, String name) {
			   return Optional.ofNullable(props.getProperty(name))
				                .flatMap(OptionalUtility::stringToInt)
												.filter(i -> i > 0)
												.orElse(0);
			}





Chapter 12 -- Date and Time API


  java.util.Date since Java 1.0



12.1  LocalDate, LocalTime, LocalDateTime, 
      Instant,
			Duration, and Period



  java.util.Data <====>  LocalDateTime 

	  
		 Using "Instant"


	java.util.Date now = new Date();

	Instant instant = now.toInstant();

	instant.plus(1, ChronoUtil.DAYS);

	java.util.Date tomorrow = Date.from(instant);



 
  *** Common methods of date-time classes representing an "interval"

		Method  static          notes

	  between  yes
		from     yes
		of       yes
		parse    yes
		addto    no
		get      no
		isNegative no
		isZero   no
		minus    no
		multipliedBy no
		negated  no
		plus     no
		subtractFrom  no


  *** Common methods of date-time classes representing a "point" in time

		Method  static          notes

    from    yes
		now     yes
		of      yes
		parse   yes

		atOffset no
		atZone  no
		format  no

		get     no
		minus   no
		plus    no
		with    no



 ***  factory methods of "TemporalAdjusters" 

    method                  description 

		dayOfWeekInMonth 
		firstDayOfMonth
		firstDayOfNextMonth
		firstDayOfNextYear
		firstDayOfYear
		firstInMonth

		lastDayOfMonth
		lastDayOfNextMonth
		lastDayOfNextYear
		lastDayOfYear
		lastInMonth

		next
		previous

		nextOrSame
		prveiousOrSame
















