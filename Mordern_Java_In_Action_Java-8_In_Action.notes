

Chapter 2  lambda


1) lambda

  inventory.sort((Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight()));



2)	Functional Interface  (@FunctionalInterface)

    ^^ Only 1 abstract method.


		a.  Predicate<T>     --  test(...)


    b.  Consume<T>       --  accept(...)


		c.  Function<T, R>   --  apply(...)


		d.  Supplier<T>      --  () -> T


		e. UnaryOperator<T>  --   T -> T


		f. BinaryOperator<T> --  (T, T) -> T


		g. BiPredicate<T, U> -- (T, U) -> boolean


		h. BiConsumer<T, U>  -- (T, U) -> void


		i. BiFunction<T, U, R> -- (T, U) -> R




3.8 Useful methods to compose lambda expressions


  1) composing "Comparators"
	   
		 inventory.sort(comparing(Apple::getWeight).reversed());


		 ^^ Comparator.comparing static method returns a Comparator ...


		 ^^ Chaining comparactors

		    inventory.sort(comparing(Apple::getWeight)
				                 .reversed()
												 .thenComparing(Apple::getCountry)
				               );


  2) composing "Predicates"


     *** existing Predicate -- negate, and, or


		 Predicate<Apple> notRedApple = redApple.negate();   // here redApple is a Predicate


		 Predicate<Apple> redAndHeavyApple = redApple.and(apple -> apple.getWeight() > 150);

		 Predicate<Apple> redAndHeaveyAppleOrGreen 
		      = redApple.and(a -> a.getWeight() > 150).or(a -> GREEN.equals(a.getColor()));



  3) composing "Functions"

	   "Function" interface comes with two default methods, "andThen",  "compose",  both returns instance of "Funmction"


		 Function<Integer, Integer> plus1 = x -> x + 1;

		 Function<Integer, Integer> times2 = x -> x * 2;

		 Function<Integer, Integer> plus1AndThenTimes2 = plus1.andThen(times2);

		 Integer rslt = plus1AndThenTimes2.apply(2);   // rslt is:  (2 + 1) * 2 == 6

     ^^^ same as Math :   times2(plus1(x))


		 Now, how about plus1(times2(x))

		 Function<Integer, Integer> comp = plus1.compose(times2);    // 

		 Integer rslt = comp.apply(2);   // the result is  2 * 2 + 1 == 5



  4) similar ideas from mathematics 

	   a) integration :   

  





Chapter 5 Using Streams


  5.2 Slicing a stream 

	   *** slicking using a predicate

		   Java 9 added 2 new methods:  "takeWhile" -- lets you slice any stream (including infinite stream) using a "predicate",  and it stops once it has found an element that "fails" to match.

		List<Dish> slicedMenu1 = specialMenu.stream()
		                            .takeWhile(dish -> dish.getCalories() < 320)
																.collect(toList());



     "dropWhile" -- not taking elements matching the Predicate

		 List<Dish> menuWithCaloriesGreaterThan320 = specialMenu.stream()
		                            .dropWhile(dish -> dish.getCalories() < 320)
																.collect(toList());

		                
