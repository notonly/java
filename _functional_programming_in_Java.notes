

These books are goo:

1) Functional Programming in Java -- Pierre-Yves Saumont
2) Java Performance Companion -- Charlie Hunt ...
3) Java By Comparison -- Simon Harrer


Functional Programming:

1) First-class function

2) annoymonous function

3) closures

4) carrying

5) lazy evaluation

6) parametic polymophism


============= some concepts

1) what is a function ? 

   mathematical object, 

	 in real world, a relation between as "source set" -- called "function domain"
	      to a "target set" -- called function "co-domain".

2) Inverse Fucntions

   f(x) is a function from domain A to codomain B;

	 and then, f'(x) from B to A  is called "inverse"


3)  Partial Functions

   A relation that "isn't defined" for "all elements of the domain" but that fulfills 
	 the "rest of the requirements -- no element of the domain can have the relationship 
	 with more than one element of the co-domain"  is often called "partial function".


	 Partial functions are important in programming, because many bugs are the result of
	 using a partial function "as if" it were a "total" one.  


	 ***  By adding an element to the codomain (the error condition -- similar to the
	 switch statement's "default" case),  and then we can transform "partial func"
	 into "total function"


	 Returning "partial functions" into total ones is an important part 
	 of functional programming.  <== to "avoid bugs"


4) Function composition

   building blocks for other functions.

	 math defn :  F o G  -- f found g

	 F o G (x) = f(g(x))


	 note the functions are applied in inverse of writing order.

	 Java 8 defines compose() method, the andThe() method to represent the composition, 

	 f.andThen(g)  is SAME as g.compose(f)


5) Functions with several arguments

   f(x, y) ...


6) Function currying 

   f(x)(y) = g(y)

	 the result of applying function f to the argument x is a new function g.  

	 when applyingg, x is no londer a variable. 


	 f(x)(y) is the "curried" form of function f(x, y), 
	 Applying this transformation to a function of a tuple (which you can
	 call a function of several arguments if you prefer) is called "currying",
	 after the mathematician Haskell Curry (he was not the inventor of this transformation)


	 Note, there is Haskell programming language, a Functional programming.


7) Partially applied functions

   example:

	 f(rate, price) = price / 100 * (100 + rate)

	 Seems equivalent to 

	 g(price, rate) = price / 100 * (100 + rate)


	 Note, f, g function have swapped order of arguments


Now, consider the "curried" version of these 2 functions:

   f(rate)(price)
	 g(price)(rate)


	 saying, f(rate) is a function of a price to a price.  If rate = 9, this function 
	 applies a tax of 9% to a price, giving a new price.
	 

	 But, g(price) is a function of a rate to a price.  If price = 100, it gives a new 
	 function applying a price of 100 to a variable tax.  What would you call this function"?
	 It may be useless function, depending on what you're solving.


	 Functions like f(rate) and g(price) are sometimes called "partially applied functions",
	 in reference to the forms f(rate, price) and g(price, rate).


	 Partially applying functions can have huge consequences regarding argument evaluation.



8) Understanding "currying"

   imaging travelling in foreign country, using calculator to convert currencies,
	 would you prefer having to type conversion rate each time
	 you want to compute a price, or rather put the rate in memory (intermediate result
	 from the f(rate))?

	 Which solution is less error-prone?


9) Functions in Java

   A method can be functional if it respects the requirements of "pure function"

	 a) must not mutate anything outside the function. 
	    (no internal mutation may be visible from the outside)
	
	 b) must not mutate its arguments

	 c) must not throw errors or exceptions (WOW,  was this the reason not easy to handle
	    exceptions in/from Lambda?

	 d) must always return a value  (well, Java 8 Consumer is not such cache, Runnable either)

	 e) when called with same arguments, must always return same result.


 
 public int add(int a, int b) { return a + b; }

 ^^ is a Function


 public int div(int a, int b) { return a / b; }
 ^^ Is NOT function, because it throws div/0 exception.

 To make it a function, we could test the 2nd parameter and return a value if it's null
 it would have to be an int.  


1. Recursive Functions

  public int factorial (int n) {
	  return n == 0 ? 1 : n * factorial(n -1);
	}


	Java 8 way

	*** add "final" to this member method, and use "this" to access it

	public final Function<Integer, Integer> factorial 
	  = n -> n <= 1 ? n : n * this.factorial.apply(n -1);


	*** using "static",  and "class name" replacing "this"

	public static final Function<Integer, Interger> factorial 
	  = n -> n <=1 ? n : n * MyClass.factorial.apply(n - 1);




2. Identity function

  static <T> Function<T, T> identity() {
	  return t -> t;
	}



2.0 Java Functional Interface, and Anonymous classes, lambda expression (anonymous 
function/method)


public interface Function {
  int apply(int arg);
}

Function myFuncTriple = new Function() {
  @Override
	public int apply(int arg) {
	 return arg * 3;
	}
}

(my notes:  Java 8 way, using lambda) 
Function myFuncTriple2 = x -> x * 3;


^^ this function can be applied to an argument:

System.out.println(myFuncTriple(7));  // 21

System.out.println(myFuncTriple2(7));  // 21





2.1 "Composing Function"

  Function composition is a binary operation on functions ...


  Function compose(final Function f1, final Function f2) {
	  return new Function() {
		   @Override
			 public int apply(int arg) {
			   return f1.apply(f2.apply(arg));
			 }
		}
  }


	Function triple = new Function {
	  @Override 
		public int apply(int arg) {
		  return arg * 3;
		}
	}

	Function square = new Function {
	  @Override
		public int apply(int arg) {
		  return arg * 2;
		}
	}


^^ Now calling the method

System.out.println(compse(x -> x + 1,  x -> x * 2).apply);  // 


	Or in Java 8 way (my try)

	Function compose2 = (Function f1, Function f2) -> f1.apply(f2.apply(x));






(type of Function not used before in projects)

<A, B, C, D> Function<A, Function<B, Function<C, Function<D, String>>>> f() {
  return a -> b -> c -> d -> String.format("%s, %s, %s, %s", a, b, c, d);
}



================= examples to be executed in JShell 

import java.util.function.Function;


public class Fnt {

    public <A, B, C, D> String f1(A a, B b, C c, D d) {
        return String.format("%s, %s, %s, %s", a, b, c, d);
    }

    public <A, B, C, D> Function<A, Function<B, Function<C, Function<D, String>>>> f2() {
        return a -> b -> c -> d -> String.format("%s, %s, %s, %s", a, b, c, d);
    }
}

Fnt fnt = new Fnt();

String r1 = fnt.f1("hello", "world!", "it's", "me");

System.out.println("calling function f1 (traditional way): " + r1);

String rslt = fnt.f2().apply("hello").apply("world!").apply("its").apply("me");

System.out.println("calling function f2, new way: " + rslt);



^^ The results:  

calling function f1 (traditional way): hello, world!, it's, me

calling function f2, new way: hello, world!, its, me


=======================











3. Function interface


  public interface Function<T, U> {

	  U apply (T arg);

		default <V> Function<V, U> compose(Function<V, T> f) {
		  return x -> apply(f.apply(x));
		}

		default <V> Function<T, V> andThen(Function<U, V> f) {
		  return x -> f.apply(apply(x));
		}

		static <T> Function<T, T> identity() {
		  return t -> t;
		}

		static <T, U, V> Function<V, U> compose(Function<T, U> f, Function<V, T> g) {
		  return x -> f.apply(g.apply(x);
		}

		static <T, U, V> Function<T, V> andThen(Function<T, U> f, Function<U, V> g) {

			// here f <T, U> , so x is of T,  and f.apply(x) is of U;   
			// and then g <U, V>  having input of U,  and returns type of V

		  return x -> g.apply(f.apply(x));   
			
		}

    
		// higher order comp...
		static <T, U, V> Function<Function<T, U>, Function<Function<U, V>, Function<T, V>>>
		   compose() {

         return x -> y -> y.andThen(x);
		}





